{"./":{"url":"./","title":"介绍","keywords":"","body":"Introduction All for the purpose not to marry out of love is where bullying 化用这句话： 所有不知应用场景的学习，都是瞎学。 "},"mysql/SUMMARY.html":{"url":"mysql/SUMMARY.html","title":"1.MySQL","keywords":"","body":"Summary Introduction "},"mysql/":{"url":"mysql/","title":"1.1安装配置","keywords":"","body":"Introduction "},"mysql/windos-install.html":{"url":"mysql/windos-install.html","title":"1.1.1windos","keywords":"","body":""},"mysql/ubuntu-install.html":{"url":"mysql/ubuntu-install.html","title":"1.1.2ubuntu","keywords":"","body":""},"mysql/centos-install.html":{"url":"mysql/centos-install.html","title":"1.1.3centos","keywords":"","body":""},"redis-introduction.html":{"url":"redis-introduction.html","title":"2.redis","keywords":"","body":"Introduction All for the purpose not to marry out of love is where bullying 化用这句话： 所有不知应用场景的学习，都是瞎学。 "},"redis/redis-install.html":{"url":"redis/redis-install.html","title":"2.1安装配置","keywords":"","body":"背景 redis和mysql要根据具体业务场景去选型 mysql：数据放在磁盘 redis：数据放在内存 redis适合放一些频繁使用，比较热的数据，因为是放在内存中，读写速度都非常快 首先要知道mysql存储在磁盘里，redis存储在内存里，redis既可以用来做持久存储，也可以做缓存，而目前大多数公司的存储都是mysql + redis, 其中：mysql作为主存储，redis作为辅助存储被用作缓存，加快访问读取的速度，提高性能。 那么为什么不直接全部用redis存储呢？ 因为redis存储在内存中，如果存储在内存中，存储容量肯定要比磁盘少很多，那么要存储大量数据，只能花更多的钱去购买内存，造成在一些不需要高性能的地方是相对比较浪费的，所以目前基本都是mysql(主) + redis(辅)，在需要性能的地方使用redis，在不需要高性能的地方使用mysql，好钢用在刀刃上 mysql支持sql查询，可以实现一些关联的查询以及统计； redis对内存要求比较高，在有限的条件下不能把所有数据都放在redis mysql偏向于存数据，redis偏向于快速取数据，但redis查询复杂的表关系时不如mysql，所以可以把热门的数据放redis，mysql存基本数据 "},"redis/redis-windos-install.html":{"url":"redis/redis-windos-install.html","title":"2.1.1. windos","keywords":"","body":"2.1.1 redis之windows版本安装 1. 下载 github redis-download 2. 解压到安装目录 3.启动服务端 redis-server.exe redis.windows.conf 4. 启动客户端 Redis-cli.exe redis-cli.exe -h 127.0.0.1 -p 6379 5. 绑定ip设置密码 进入安装目录修改redis.windows-conf文件 requirepass 1qaz2wsx bind 0.0.0.0 redis-cli.exe -p 6379 -a 1qaz2wsx "},"redis/redis-ubuntu-install.html":{"url":"redis/redis-ubuntu-install.html","title":"2.1.2. ubuntu","keywords":"","body":""},"redis/redis-centos-install.html":{"url":"redis/redis-centos-install.html","title":"2.1.3. centos","keywords":"","body":""},"redis/redis-config.html":{"url":"redis/redis-config.html","title":"2.1.4. config","keywords":"","body":"2.1.4 redis之配置参数 # 默认情况下，redis不是在后台模式运行的，如果需要在后台进程运行，把该项的值更改为yes，默认为no daemonize：是否以后台daemon方式运行 # 如redis服务以后台进程运行的时候，Redis默认会把pid写入/run/redis.pid文件组，你可以配置到其他文件路径。 # 当运行多个redis服务时，需要指定不同的pid文件和端口 pidfile：pid文件位置 # 指定redis监听端口，默认为6379 # 如果端口设置为0，Redis就不会监听TCP套接字。 port：监听的端口号 # 指定redis只接收来自于该IP地址的请求，如果不进行设置，默认将处理所有请求， # 在生产环境中最好设置该项 bind 127.0.0.1 # 设置客户端连接时的超时时间，单位为秒。当客户端在这段时间内没有发出任何指令，那么关闭该连接 # 默认值：0代表禁用，永不关闭 timeout：请求超时时间 # 指定用来监听连接的unxi套接字的路径。这个没有默认值，所以如果不指定的话，Redis就不会通过unix套接字来监听。 # unixsocket /tmp/redis.sock # unixsocketperm 755 # 指定日志记录级别 # Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose # debug 记录很多信息，用于开发和测试 # varbose 很多精简的有用信息，不像debug会记录那么多 # notice 普通的verbose，常用于生产环境 # warning 只有非常重要或者严重的信息会记录到日志 loglevel：log信息级别 # 配置log文件名称和全路径地址 # 默认值为stdout，使用“标准输出”，默认后台模式会输出到/dev/null logfile：log文件位置 # 可用数据库数，默认值为16，默认数据库存储在DB 0号ID库中，无特殊需求，建议仅设置一个数据库 databases 1 # 查询数据库使用 SELECT # dbid介于 0 到 'databases'-1 之间 databases：开启数据库的数量 save * *：保存快照的频率，第一个*表示多长时间，第三个*表示执行多少次写操作。在一定时间内执行一定数量的写操作时，自动保存快照。可设置多个条件。 rdbcompression：是否使用压缩 dbfilename：数据快照文件名（只是文件名，不包括目录） dir：数据快照的保存目录（这个是目录） appendonly：是否开启appendonlylog，开启的话每次写操作会记一条log，这会提高数据抗风险能力，但影响效率。 appendfsync：appendonlylog如何同步到磁盘（三个选项，分别是每次写都强制调用fsync、每秒启用一次fsync、不调用fsync等待系统自己同步） ########## REPLICATION 同步 ########## # 主从同步。通过 slaveof 配置来实现Redis实例的备份。 # 注意，这里是本地从远端复制数据。也就是说，本地可以有不同的数据库文件、绑定不同的IP、监听不同的端口。 # 当本机为从服务时，设置主服务的IP及端口，在Redis启动时，它会自动从主服务进行数据同步 # slaveof # 如果主服务master设置了密码(通过下面的 \"requirepass\" 选项来配置)，slave服务连接master的密码，那么slave在开始同步之前必须进行身份验证，否则它的同步请求会被拒绝。 #当本机为从服务时，设置主服务的连接密码 # masterauth # 当一个slave失去和master的连接，或者同步正在进行中，slave的行为有两种可能： # 1) 如果 slave-serve-stale-data 设置为 \"yes\" (默认值)，slave会继续响应客户端请求，可能是正常数据，也可能是还没获得值的空数据。 # 2) 如果 slave-serve-stale-data 设置为 \"no\"，slave会回复\"正在从master同步(SYNC with master in progress)\"来处理各种请求，除了 INFO 和 SLAVEOF 命令。 slave-serve-stale-data yes # slave根据指定的时间间隔向服务器发送ping请求。 # 时间间隔可以通过 repl_ping_slave_period 来设置。 # 默认10秒 # repl-ping-slave-period 10 # 下面的选项设置了大块数据I/O、向master请求数据和ping响应的过期时间。 # 默认值60秒。 # 一个很重要的事情是：确保这个值比 repl-ping-slave-period 大，否则master和slave之间的传输过期时间比预想的要短。 # repl-timeout 60 ########## SECURITY 安全 ########## # 要求客户端在处理任何命令时都要验证身份和设置密码。 # 如果你不相信请求者，这个功能很有用。 # 为了向后兼容的话，这段应该注释掉。而且大多数人不需要身份验证(例如：它们运行在自己的服务器上。) # 警告：外部使用者可以每秒尝试150k的密码来试图破解密码，这意味着你需要一个高强度的密码，否则破解太容易了。 # 设置连接密码 # requirepass foobared # 命令重命名，可设置多个 # 在共享环境下，可以为危险命令改变名字。比如，你可以为 CONFIG 改个其他不太容易猜到的名字，这样你自己仍然可以使用，而别人却没法知道它。 # 例如: # rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52 # rename-command info info_biran # rename-command set set_biran # 甚至也可以通过给命令赋值一个空字符串来完全禁用这条命令： # rename-command CONFIG \"\" ########## LIMITS 限制 ########## # 设置最大同时连接客户端数量。 # 默认没有限制，这个关系到Redis进程能够打开的文件描述符数量。 # 特殊值\"0\"表示没有限制。 # 一旦达到这个限制，Redis会关闭所有新连接并发送错误\"达到最大用户数上限(max number of clients reached)\" # maxclients 128 # 不要用比设置的上限更多的内存。一旦内存使用达到上限，Redis会根据选定的回收策略(参见：maxmemmory-policy：内存策略设置)删除key。 # 如果因为删除策略问题Redis无法删除key，或者策略设置为 \"noeviction\"，Redis会回复需要更多内存的错误信息给命令。 # 例如，SET,LPUSH等等。但是会继续合理响应只读命令，比如：GET。 # 在使用Redis作为LRU缓存，或者为实例设置了硬性内存限制的时候(使用 \"noeviction\" 策略)的时候，这个选项还是满有用的。 # 警告：当一堆slave连上达到内存上限的实例的时候，响应slave需要的输出缓存所需内存不计算在使用内存当中。 # 这样当请求一个删除掉的key的时候就不会触发网络问题／重新同步的事件，然后slave就会收到一堆删除指令，直到数据库空了为止。 # 简而言之，如果你有slave连上一个master的话，那建议你把master内存限制设小点儿，确保有足够的系统内存用作输出缓存。 # (如果策略设置为\"noeviction\"的话就不无所谓了) # 设置最大内存，达到最大内存设置后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理后，任到达最大内存设置，将无法再进行写入操作。 # maxmemory 256000000分配256M内存 # maxmemory # 内存策略：如果达到内存限制了，Redis如何删除key。你可以在下面五个策略里面选： # volatile-lru -> 根据LRU算法生成的过期时间来删除。 # allkeys-lru -> 根据LRU算法删除任何key。 # volatile-random -> 根据过期设置来随机删除key。 # allkeys->random -> 无差别随机删。 # volatile-ttl -> 根据最近过期时间来删除(辅以TTL) # noeviction -> 谁也不删，直接在写操作时返回错误。 # 注意：对所有策略来说，如果Redis找不到合适的可以删除的key都会在写操作时返回一个错误。 # 这里涉及的命令：set setnx setex append # incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd # sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby # zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby # getset mset msetnx exec sort # 默认值如下： # maxmemory-policy volatile-lru # LRU和最小TTL算法的实现都不是很精确，但是很接近(为了省内存)，所以你可以用样例做测试。 # 例如：默认Redis会检查三个key然后取最旧的那个，你可以通过下面的配置项来设置样本的个数。 # maxmemory-samples 3 ########## APPEND ONLY MODE 纯累加模式 ########## # 默认情况下，Redis是异步的把数据导出到磁盘上。因为redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中，这种情况下，当Redis宕机的时候，最新的数据就丢了。 # 如果不希望丢掉任何一条数据的话就该用纯累加模式：一旦开启这个模式，Redis会把每次写入的数据在接收后都写入 appendonly.aof 文件。 # 每次启动时Redis都会把这个文件的数据读入内存里。 # 注意，异步导出的数据库文件和纯累加文件可以并存(此时需要把上面所有\"save\"设置都注释掉，关掉导出机制)。 # 如果纯累加模式开启了，那么Redis会在启动时载入日志文件而忽略导出的 dump.rdb 文件。 # 重要：查看 BGREWRITEAOF 来了解当累加日志文件太大了之后，怎么在后台重新处理这个日志文件。 # 设置：yes为纯累加模式 appendonly no # 设置纯累加文件名字及保存路径，默认：\"appendonly.aof\" # appendfilename appendonly.aof # fsync() 请求操作系统马上把数据写到磁盘上，不要再等了。 # 有些操作系统会真的把数据马上刷到磁盘上；有些则要磨蹭一下，但是会尽快去做。 # Redis支持三种不同的模式： # no：不要立刻刷，只有在操作系统需要刷的时候再刷。比较快。 # always：每次写操作都立刻写入到aof文件。慢，但是最安全。 # everysec：每秒写一次。折衷方案。 # 默认的 \"everysec\" 通常来说能在速度和数据安全性之间取得比较好的平衡。 # 如果你真的理解了这个意味着什么，那么设置\"no\"可以获得更好的性能表现(如果丢数据的话，则只能拿到一个不是很新的快照)； # 或者相反的，你选择 \"always\" 来牺牲速度确保数据安全、完整。 # 如果不确定这些模式的使用，建议使用 \"everysec\" # appendfsync always appendfsync everysec # appendfsync no # 如果AOF的同步策略设置成 \"always\" 或者 \"everysec\"，那么后台的存储进程(后台存储或写入AOF日志)会产生很多磁盘I/O开销。 # 某些Linux的配置下会使Redis因为 fsync() 而阻塞很久。 # 注意，目前对这个情况还没有完美修正，甚至不同线程的 fsync() 会阻塞我们的 write(2) 请求。 # 为了缓解这个问题，可以用下面这个选项。它可以在 BGSAVE 或 BGREWRITEAOF 处理时阻止 fsync()。 # 这就意味着如果有子进程在进行保存操作，那么Redis就处于\"不可同步\"的状态。 # 这实际上是说，在最差的情况下可能会丢掉30秒钟的日志数据。(默认Linux设定) # 如果你有延迟的问题那就把这个设为 \"yes\"，否则就保持 \"no\"，这是保存持久数据的最安全的方式。 no-appendfsync-on-rewrite no # 自动重写AOF文件 # 如果AOF日志文件大到指定百分比，Redis能够通过 BGREWRITEAOF 自动重写AOF日志文件。 # 工作原理：Redis记住上次重写时AOF日志的大小(或者重启后没有写操作的话，那就直接用此时的AOF文件)， # 基准尺寸和当前尺寸做比较。如果当前尺寸超过指定比例，就会触发重写操作。 # 你还需要指定被重写日志的最小尺寸，这样避免了达到约定百分比但尺寸仍然很小的情况还要重写。 # 指定百分比为0会禁用AOF自动重写特性。 auto-aof-rewrite-percentage 100 auto-aof-rewrite-min-size 64mb ########## SLOW LOG 慢查询日志 ########## # Redis慢查询日志可以记录超过指定时间的查询。运行时间不包括各种I/O时间。 # 例如：连接客户端，发送响应数据等。只计算命令运行的实际时间(这是唯一一种命令运行线程阻塞而无法同时为其他请求服务的场景) # 你可以为慢查询日志配置两个参数：一个是超标时间，单位为微妙，记录超过个时间的命令。 # 另一个是慢查询日志长度。当一个新的命令被写进日志的时候，最老的那个记录会被删掉。 # 下面的时间单位是微秒，所以1000000就是1秒。注意，负数时间会禁用慢查询日志，而0则会强制记录所有命令。 slowlog-log-slower-than 10000 # 这个长度没有限制。只要有足够的内存就行。你可以通过 SLOWLOG RESET 来释放内存。 slowlog-max-len 128 ########## VIRTUAL MEMORY 虚拟内存 ########## ### 警告！虚拟内存在Redis 2.4是反对的，因性能问题，2.4版本 VM机制彻底废弃，不建议使用此配置！！！！！！！！！！！ # 虚拟内存可以使Redis在内存不够的情况下仍然可以将所有数据序列保存在内存里。 # 为了做到这一点，高频key会调到内存里，而低频key会转到交换文件里，就像操作系统使用内存页一样。 # 要使用虚拟内存，只要把 \"vm-enabled\" 设置为 \"yes\"，并根据需要设置下面三个虚拟内存参数就可以了。 vm-enabled no # 这是交换文件的路径。估计你猜到了，交换文件不能在多个Redis实例之间共享，所以确保每个Redis实例使用一个独立交换文件。 # 最好的保存交换文件(被随机访问)的介质是固态硬盘(SSD)。 # *** 警告 *** 如果你使用共享主机，那么默认的交换文件放到 /tmp 下是不安全的。 # 创建一个Redis用户可写的目录，并配置Redis在这里创建交换文件。 vm-swap-file /tmp/redis.swap # \"vm-max-memory\" 配置虚拟内存可用的最大内存容量。 # 如果交换文件还有空间的话，所有超标部分都会放到交换文件里。 # \"vm-max-memory\" 设置为0表示系统会用掉所有可用内存，建议设置为剩余内存的60%-80%。 # 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0。 vm-max-memory 0 # Redis交换文件是分成多个数据页的。 # 一个可存储对象可以被保存在多个连续页里，但是一个数据页无法被多个对象共享。 # 所以，如果你的数据页太大，那么小对象就会浪费掉很多空间。 # 如果数据页太小，那用于存储的交换空间就会更少(假定你设置相同的数据页数量) # 如果你使用很多小对象，建议分页尺寸为64或32个字节。 # 如果你使用很多大对象，那就用大一些的尺寸。 # 如果不确定，那就用默认值 :) vm-page-size 32 # 交换文件里数据页总数。 # 根据内存中分页表(已用/未用的数据页分布情况)，磁盘上每8个数据页会消耗内存里1个字节。 # 交换区容量 = vm-page-size * vm-pages # 根据默认的32字节的数据页尺寸和134217728的数据页数来算，Redis的数据页文件会占4GB，而内存里的分页表会消耗16MB内存。 # 为你的应验程序设置最小且够用的数字比较好，下面这个默认值在大多数情况下都是偏大的。 vm-pages 134217728 # 同时可运行的虚拟内存I/O线程数，即访问swap文件的线程数。 # 这些线程可以完成从交换文件进行数据读写的操作，也可以处理数据在内存与磁盘间的交互和编码/解码处理。 # 多一些线程可以一定程度上提高处理效率，虽然I/O操作本身依赖于物理设备的限制，不会因为更多的线程而提高单次读写操作的效率。 # 特殊值0会关闭线程级I/O，并会开启阻塞虚拟内存机制。 # 设置最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的.可能会造成比较长时间的延迟,但是对数据完整性有很好的保证. vm-max-threads 4 ########## ADVANCED CONFIG 高级配置 ########## # 当有大量数据时，适合用哈希编码(这会需要更多的内存)，元素数量上限不能超过给定限制。 # Redis Hash是value内部为一个HashMap，如果该Map的成员数比较少，则会采用类似一维线性的紧凑格式来存储该Map, 即省去了大量指针的内存开销，如下2个条件任意一个条件超过设置值都会转换成真正的HashMap， # 当value这个Map内部不超过多少个成员时会采用线性紧凑格式存储，默认是64,即value内部有64个以下的成员就是使用线性紧凑存储，超过该值自动转成真正的HashMap。 hash-max-zipmap-entries 512 # 当 value这个Map内部的每个成员值长度不超过多少字节就会采用线性紧凑存储来节省空间。 hash-max-zipmap-value 64 # 与hash-max-zipmap-entries哈希相类似，数据元素较少的情况下，可以用另一种方式来编码从而节省大量空间。 # list数据类型多少节点以下会采用去指针的紧凑存储格式 list-max-ziplist-entries 512 # list数据类型节点值大小小于多少字节会采用紧凑存储格式 list-max-ziplist-value 64 # 还有这样一种特殊编码的情况：数据全是64位无符号整型数字构成的字符串。 # 下面这个配置项就是用来限制这种情况下使用这种编码的最大上限的。 set-max-intset-entries 512 # 与第一、第二种情况相似，有序序列也可以用一种特别的编码方式来处理，可节省大量空间。 # 这种编码只适合长度和元素都符合下面限制的有序序列： zset-max-ziplist-entries 128 zset-max-ziplist-value 64 # 哈希刷新，每100个CPU毫秒会拿出1个毫秒来刷新Redis的主哈希表(顶级键值映射表)。 # redis所用的哈希表实现(见dict.c)采用延迟哈希刷新机制：你对一个哈希表操作越多，哈希刷新操作就越频繁； # 反之，如果服务器非常不活跃那么也就是用点内存保存哈希表而已。 # 默认是每秒钟进行10次哈希表刷新，用来刷新字典，然后尽快释放内存。 # 建议： # 如果你对延迟比较在意的话就用 \"activerehashing no\"，每个请求延迟2毫秒不太好嘛。 # 如果你不太在意延迟而希望尽快释放内存的话就设置 \"activerehashing yes\"。 activerehashing yes ########## INCLUDES 包含 ########## # 包含一个或多个其他配置文件。 # 这在你有标准配置模板但是每个redis服务器又需要个性设置的时候很有用。 # 包含文件特性允许你引人其他配置文件，所以好好利用吧。 # include /path/to/local.conf # include /path/to/other.conf 修改配置后，如果配置文件涉及到中文内容记得将文件存为UTF-8编码。 "},"redis/redis-usage.html":{"url":"redis/redis-usage.html","title":"2.2数据操作","keywords":"","body":"2.2 redis操作类型 Redis是一个开源的Key-Value存储redis层面，永远只有一个键（字符串对象，值的种类有字符串对象，队列对象，集合对象，hash对象） string类型 增删改查：set get del decrby（减少指定整数） incrby（增加指定整数） incrbyfloat（增加指定的单精度） 批量：mset mget 自增, 自减：incr decr 追加：append（返回长度） 删除所有的key flushall 获取getrange hash类型 增删改查：hset hget hgetall keys hkeys keys hvals keys hdel keys field list类型 lisy是基于双向链表实现的，用于评论系统，新闻分页列表，消息队列等 lpush 左边插入 返回个数 rpush 右边插入 返回个数 lpop 移除左边 返回移除的值 rpop 移除右边 llen 列表个数 lrange key start stop 下标 （0 -1全部，0 1 前两个，-2 -1 倒数最后两个） set集合 增删改查： sadd srem/spop(随机弹出元素) smembers 个数 scard zset有序集合 增删改查： zadd "},"redis/redis-string.html":{"url":"redis/redis-string.html","title":"2.2.1. string","keywords":"","body":"2.2.1 String字符串基本操作 字符串类型是 Redis 最基础的数据结构，首先键都是字符串类型，而且 其他几种数据结构都是在字符串类型基础上构建的， 我们常使用的 set key value 命令就是字符串。 常用在缓存、计数、共享Session、限速等。 常用操作命令如下 序号 命令 描述 1 set key value 设置指定 key 的值 2 get key 获取指定 key 的值 3 mset key value key2 value2 同时设置一个或多个 key-value 对。 4 mget key1 key2 获取所有(一个或多个)给定 key 的值 5 setnx key value 只有在 key 不存在时设置 key 的值 6 setex key seconds value 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位) 7 strlen key 返回 key 所储存的字符串值的长度 8 incr key 将 key 中储存的数字值增一 9 decr key 将 key 中储存的数字值减一 10 getrange key start end 返回 key 中字符串值的子字符 11 getset key value 将给定 key 的值设为 value ，并返回 key 的旧值(old value) 1.1 常用操作命令 SET 命令用于设置给定 key 的值。如果 key 已经存储其他值， SET 就覆写旧值，且无视类型。 设置键值 set key value set username zhangsan GET 根据键获取值，如果不存在此键则返回nil get key get username MSET 设置多个键值 mset key1 value1 key2 value2 ... mset zhangsan 18 lisi 19 wangwu 20 追加 append key value append maliu 21 和set 本质无区别，由单个设为多个而已 MGET 根据多个键获取多个值 mget key1 key2 ... mget zhangsan lisi wangwu SETEX 设置键值及过期时间，以秒为单位 setex key seconds value setex token 3 JZJOViZOdHcczGDEXMeu8lZe 注 setex zhangsan 18 18 lisi 19 19 wangwu 20 20 没有此用法 INCR 将key中储存的数字增加一 incr key set read 2000 incr read # 此时输出2001 注: 阅读量点赞量评论量 DECR 将key中储存的数字减一 decr key set read 2000 decr read # 此时输出1999 注: 一些资源的消耗 SETNX 只有在 key 不存在时设置 key 的值 setnx key value setnx name zhangsan 注: 已有key值情况下，不会覆盖更新，也不会创建新的 STRLEN 返回 key 所储存的字符串值的长度 strlen key strlen name # 输出为8 zhangsan 基本的命令：get、set 语法：get key，set key value value如果有空格需要双引号以示区分 整数递增：incr 语法：incr key 默认值为0，所以首先执行命令得到 1 ，不是整型提示错误 增加指定的整数：incrby 语法：incrby key increment 整数递减：decr 语法：decr key 默认值为0，所以首先执行命令得到 -1，不是整型提示错误 减少指定的整数：decrby 语法：decrby key increment 增加指定浮点数：incrbyfloat 语法：incrbyfloat key increment 向尾部追加值：append 语法：append key value redis客户端并不是输出追加后的字符串，而是输出字符串总长度 获取字符串长度：strlen语法：strlen key 如果键不存在返回0，注意如果有中文时，redis是使用utf-8编码中文 获取多个键值：mget 语法：mget key key2 例如：mget key1 key2 设置多个键值：mset 语法：mset key value key2 value2 例如：mset key1 1 key2 \"hello redis\" 二进制指定位置值：getbit 语法：getbit key offset 例如：getbit key1 2 ，key1为hello 返回 1，返回的值只有0或1，当key不存在或超出实际长度时为0 设置二进制位置值：setbit 语法：setbit key offset value ，返回该位置的旧值 二进制是1的个数：bitcount 语法：bitcount key [start end] ，start 、end为开始和结束字节 位运算：bitop 语法：bitop operation destkey key key2，operation支持and、or、xor、not 偏移：bitpos 语法：bitpos key bit [start] [end] "},"redis/redis-key.html":{"url":"redis/redis-key.html","title":"2.2.2. key","keywords":"","body":"2.2.2 key命令基本操作 常用操作命令如下 序号 命令 描述 1 keys pattern 查找键，参数⽀持正则表达式 2 exists key 判断键是否存在，如果存在返回1，不存在返回0 3 type key 查看键对应的value的类型 4 del key1 key2 ... 删除键及对应的值 5 expire key seconds 设置过期时间，以秒为单位， 有指定过期时间则⼀直存在，直到使⽤DEL移除 查看所有键 keys * 查看以a开头的键 keys zhang* 查看key为张三键是否存在 exists zhangsan 查看key为redis类型 type key 删除某键 del key1 key2 设立过期时间 expire zhangsan 20 "},"redis/redis-hash.html":{"url":"redis/redis-hash.html","title":"2.2.3. hash","keywords":"","body":"2.2.3 Hash哈希基本操作 在Redis中，哈希类型是指键值本身又是一个键值对 结构， 形如value={{field1，value1}，…{fieldN，valueN}}， 添加命令：hset key field value。 哈希可以用来存放用户信息，比如实现购物车 常用操作命令如下 1 hset key field value 设置单个属性将哈希表 key 中的字段 field 的值设为 value 2 hkeys key 获取⼀个属性的值获取存储在哈希表中指定字段的值 3 hmset key field1 value1 field2 value2 设置多个属性同时将多个 field-value (域-值)对设置到哈希表 key 中 4 hmget key field1 field2 ... 获取多个属性的值获取所有给定字段的值 4 hmgetall key 获取在哈希表中指定 key 的所有字段和值 4 hexists key field 查看哈希表key中，指定的字段是否存在 4 hsetnx key field value 只有在字段 field 不存在时，设置哈希表字段的值 5 hkeys key 获取指定键所有的属性 6 hvals key 获取所有属性的值 7 del key 删除整个hash键及值 8 hdel key field1 field2 ... 删除属性，属性对应的值会被⼀起删除删除一个或多个哈希表字段 散列类型hash 设置单个：HSET 语法：HSET key field value，不存在时返回1，存在时返回0，没有更新和插入之分 设置多个：HMSET 语法：HMSET key field value [field value ...] 读取单个：HGET 语法：HGET key field，不存在是返回nil 读取多个：HMGET 语法：HMGET key field [field ...] 读取全部：HGETALL 语法：HGETALL key，返回时字段和字段值的列表 判断字段是否存在：HEXISTS 语法：HEXISTS key field，存在返回1 ，不存在返回0 字段不存在时赋值：HSETNX 语法：HSETNX key field value，与hset命令不同，hsetnx是键不存在时设置值 增加数字：HINCRBY 语法：HINCRBY key field increment ，返回增加后的数，不是整数时会提示错误 删除字段：HDEL 语法：HDEL key field [field ...] ，返回被删除字段的个数 只获取字段名：HKEYS 语法：HKEYS key ，返回键的所有字段名 只获取字段值：HVALS 语法：HVALS key ，返回键的所有字段值 字段数量：HLEN 语法：HLEN key ，返回字段总数 "},"redis/redis-list.html":{"url":"redis/redis-list.html","title":"2.2.4. list","keywords":"","body":"2.2.4 list列表基本操作 常见的存储结构,它是一个双向链表,即可以作为栈结构也可以作为队列结构. 列表的元素类型为string, 按照插⼊顺序排序，可以在列表头部尾部添加元素 常用操作命令如下 1 llen key 获取列表长度 2 lpush key value1 value2 将一个或多个值插入到列表头部 3 lpop key 移出并获取列表的第一个元素 4 rpush key value1 value2 据将一个或多个值插入到列表尾部 5 rpop key 移除并获取列表最后一个元素 6 linsert key before 现有元素 新元素 在指定元素的前插⼊新元素 7 linsert key after 现有元素 新元素 在指定元素后插⼊新元素 8 lrange key start stop 获取列表指定范围内的元素 tart、stop为元素的下标索引 索引从左侧开始，第⼀个元素为0索引可以是负数 表示从尾部开始计数，如-1表示最后⼀个元素 列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。 9 lset key index value 设置指定索引位置的元素值 10 lrem key count value 将列表中前count次出现的值为value的元素移除 count>0:从头往尾移除 count count = 0: 移除所有 11 rpushx key value 为已存在的列表添加值 使用场景 1. 取出最新n个消息(不涉及复杂排序) 比如最新1000个访客,就可以使用list,同时使用LTRIM key 0 1000,只保存最新的1000个 2. 作为队列 将Redis用作日志收集器, 多个端点将日志信息push到Redis,然后一个worker统一将所有日志写到磁盘rpop 3. 取最新N个数据的操作 记录前N个最新登陆的用户Id列表，超出的范围可以从数据库中获得。 把当前登录人添加到链表里 ret = r.lpush(\"login:last_login_times\", uid) 保持链表只有N位 ret = redis.ltrim(\"login:last_login_times\", 0, N-1) 获得前N个最新登陆的用户Id列表 last_login_list = r.lrange(\"login:last_login_times\", 0, N-1) 比如sina微博： 在Redis中我们的最新微博ID使用了常驻缓存，这是一直更新的。 但是我们做了限制不能超过5000个ID，因此我们的获取ID函数会一直询问Redis。 只有在start/count参数超出了这个范围的时候，才需要去访问数据库。 我们的系统不会像传统方式那样“刷新”缓存，Redis实例中的信息永远是一致的。SQL数据库只是在用户需要获取“很远”的数据时才会被触发，而主页或第一个评论页是不会麻烦到硬盘上的数据库了 列表类型（list） 内部使用双向链表实现，所以获取越接近两端的元素速度越快，但通过索引访问时会比较慢 添加左边元素：LPUSH 语法：LPUSH key value [value ...] ，返回添加后的列表元素的总个数 添加右边元素：RPUSH 语法：RPUSH key value [value ...] ，返回添加后的列表元素的总个数 移除左边第一个元素：LPOP 语法：LPOP key ，返回被移除的元素值 移除右边第一个元素：RPOP 语法：RPOP key ，返回被移除的元素值 列表元素个数：LLEN 语法：LLEN key， 不存在时返回0，redis是直接读取现成的值，并不是统计个数 获取列表片段：LRANGE 语法：LRANGE key start stop，如果start比stop靠后时返回空列表，0 -1 返回整个列表 正数时：start 开始索引值，stop结束索引值（索引从0开始） 负数时：例如 lrange num -2 -1，-2表示最右边第二个，-1表示最右边第一个， 删除指定值：LREM 语法：LREM key count value，返回被删除的个数 count>0，从左边开始删除前count个值为value的元素 count "},"redis/redis-set.html":{"url":"redis/redis-set.html","title":"2.2.5. set","keywords":"","body":"2.2.5 set集合基本操作 集合的概念就是一堆string类型且不重复值的无序的组合 说明：对于集合没有修改操作 Redis 中 集合是通过哈希表实现的，所以没有hash碰撞时添加，删除，查找的复杂度都是O(1),有碰撞时为O(n) 1 sadd key member1 member2 向集合添加一个或多个成员 2 smembers key 返回集合中的所有成员 3 srem key member1 member1 移除集合中一个或多个成员 4 sismember key member 判断 member 元素是否是集合 key 的成员 5 scard key 获取集合的成员数 6 sdiff key1 key2 返回给定所有集合的差集 7 sinter key1 key2 返回给定所有集合的交集 8 sunion key1 key2 返回所有给定集合的并集 使用场景: 交集，并集，差集 Set是集合，是String类型的无序集合，set是通过hashtable实现的，概念和数学中个的集合基本类似，可以交集，并集，差集等等，set中的元素是没有顺序的。 实现方式： set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。 一些会不重复的数据,进行交集,并集,差集等灵活操作抖音的关注人,粉丝,可分别放在一个set中 在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。 Redis还为集合提供求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能 对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。 //book表存储book名称 set book:1:name ”The Ruby Programming Language” set book:2:name ”Ruby on rail” set book:3:name ”Programming Erlang” //tag表使用集合来存储数据，因为集合擅长求交集、并集 sadd tag:ruby 1 sadd tag:ruby 2 sadd tag:web 2 sadd tag:erlang 3 //即属于ruby又属于web的书？ inter_list = redis.sinter(\"tag.web\", \"tag:ruby\") //即属于ruby，但不属于web的书？ inter_list = redis.sdiff(\"tag.ruby\", \"tag:web\") //属于ruby和属于web的书的合集？ inter_list = redis.sunion(\"tag.ruby\", \"tag:web\") 获取某段时间所有数据去重值 这个使用Redis的set数据结构最合适了，只需要不断地将数据往set中扔就行了，set意为集合，所以会自动排重。 集合类型（set） 集合类型值具有唯一性，常用操作是向集合添加、删除、判断某个值是否存在，集合内部是使用值为空的散列表实现的。 添加元素：SADD 语法：SADD key member [member ...] 向一个集合添加一个或多个元素，因为集合的唯一性，所以添加相同值时会被忽略。返回成功添加元素的数量。 删除元素：SREM 语法：SREM key member [member ...] 删除集合中一个或多个元素，返回成功删除的个数。 获取全部元素：SMEMBERS 语法：SMEMBERS key ，返回集合全部元素 值是否存在：SISMEMBER 语法：SISMEMBER key member ，如果存在返回1，不存在返回0 差运算：SDIFF 语法：SDIFF key [key ...] 例如：集合A和集合B，差集表示A-B，在A里有的元素B里没有，返回差集合；多个集合(A-B)-C 交运算：SINTER 语法：SINTER key [key ...]，返回交集集合，每个集合都有的元素 并运算：SUNION　语法：SUNION key [key ...]，返回并集集合，所有集合的元素 集合元素个数：SCARD 语法：SCARD key ，返回集合元素个数 集合运算后存储结果 语法：SDIFFSTROE destination key key2 ，差运算并存储到destination新集合中 SINTERSTROE destination key key2，交运算并存储到destination新集合中 SUNIONSTROE destination key [key ...]，并运算并存储到destination新集合中 随机获取元素：SRANDMEMGER 语法：SRANDMEMBER key [count] 根据count不同有不同结果，count大于元素总数时返回全部元素 count>0 ，返回集合中count不重复的元素 count "},"redis/redis-zset.html":{"url":"redis/redis-zset.html","title":"2.2.6.zset","keywords":"","body":"2.2.6 sorted set有序集合基本操作 redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。 不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 有序集合的成员是唯一的,但分数(score)却可以重复,当分数重复时,按照自然顺序排序。 明确存储对象用hash 指定存续的存储需顺序zset 需要添加循序指定 list sorted set常用操作命令如下 序号 命令 描述 1 zadd key score1 member1 score2 member2 向有序集合添加一个或多个成员，或者更新已存在成员的分数 2 zrange key start stop 返回指定范围内的元素 start、stop为元素的下标索引 索引从左侧开始，第⼀个元素为0，索引可以是负数 表示从尾部开始计数，如-1表示最后⼀个元素 3 zcard key 获取有序集合的成员数 4 zscore key member 返回有序集中，成员的分数值 5 zcount key min max 计算在有序集合中指定区间权重的成员数 6 zrangebyscore key min max [withscores] [limit] 通过分数返回有序集合指定区间内的成员 7 zrank key member 返回有序集合中指定成员的索引 8 zrem key member member2 移除有序集合中的一个或多个成员 9 zincrby key increment member 有序集合中对指定成员的分数加上增量 increment 10 zinterstore destination numkeys key key2 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中 11 zremrangebyscore key min max 移除有序集合中给定的分数区间的所有成员 12 zrevrangebyscore key max min [withscores] 返回有序集中指定分数区间内的成员，分数从高到低排序 13 zunionstore destination numkeys key key2 计算给定的一个或多个有序集的并集，并存储在新的 key 中 添加 zadd key score1 member1 score2 member2 zadd user 1 python 2 java 4 html 5 go 6 javascript 获取 zrange key start stop zrange user 1 -1 1) \"python\" 2) \"java\" 3) \"html\" 4) \"go\" 5) \"javascript\" 权重在min max 元素个数 zcount key min max zcount user 4 5 获取有序集合的成员数 zcard key zcard user 5 返回有序集中，成员的分数值 zscore key member zscore user java 2 通过分数返回有序集合指定区间内的成员 zrangebyscore key min max zrangebyscore user 3 6 1) \"html\" 2) \"go\" 3) \"javascript\" 返回有序集合中指定成员的索引 zrank key member zrank user java 2 zrank user 0 -1 1) \"python\" 2) \"java\" 3) \"html\" 4) \"go\" 5) \"javascript\" zrank user 0 -1 withscores 1) \"python\" 2) \"1\" 3) \"java\" 4) \"2\" 5) \"html\" 6) \"4\" 7) \"go\" 8) \"5\" 9) \"javascript\" 10) \"6\" 有序集合中对指定成员的分数加上增量 zincrby key increment member zincrby user 3 java 5 返回是权重 移除有序集合中的一个或多个成员 zrem key member zrem user python 使用场景: 使用场景：Sorted Set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列，插入时自动排序。 当你需要一个有序的并且不重复的集合列表，那么可以选择sorted set数据结构, 比如twitter的public 微信朋友圈排序,分数用时间来表示, timeline可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的。 经典案例:一个班的同学按分数排序,就可以把分数作为scored,实现排序 比如一个存储全班同学成绩的Sorted Set，其集合value可以是同学的学号，而score就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。另外还可以用Sorted Set来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。 Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。 sorted sorted特点: 有序， 元素string类型， 唯一性，不重复 每个元素都会关联double类型的score， 表示权重，通过权重将元素冲销到大排序， 元素的score可以重复 添加集合元素：zadd 添加集合元素：zadd key [nx|xx] [ch] [incr] score member [score member] 不存在添加，存在更新 获取元素分数：zscore 语法：zscore key member 返回元素成员的score 分数 元素小到大：zrange 语法：zrange key start top [withscores] 加上withscores 返回带元素，即元素，分数， 当分数一样时，按元素排序 元素大到小：zrevrange 语法：zrevrange key start [withscores] 指定分数范围元素：zrangebyscore 语法：zrangebyscore key min max [withscore] [limit offest count] 返回从小到大的在min和max之间的元素, 符号表示不包含，例如：80-100，(80 100，withscore返回带分数 limit offest count 向左偏移offest个元素，并获取前count个元素 指定分数范围元素：zrevrangescore 语法：zrevrangebyscore key max min [withscore] [limit offest count] 增加分数：zincrby 语法：zincrby key increment member 注意是增加分数，返回增加后的分数 如果成员不存在，则添加一个为0的成员 "},"redis/redis-scene.html":{"url":"redis/redis-scene.html","title":"2.2.7.应用场景","keywords":"","body":"2.2.7 Redis实际应用场景 1. 显示最新的项目列表 下面这个语句常用来显示最新项目，随着数据多了，查询毫无疑问会越来越慢。 SELECT * FROM foo WHERE ... ORDER BY time DESC LIMIT 10 在Web应用中，\"列出最新的回复\"之类的查询非常普遍，这通常会带来可扩展性问题。这令人沮丧，因为项目本来就是按这个顺序被创建的，但要输出这个顺序却不得不进行排序操作。比如说，我们的一个Web应用想要列出用户贴出的最新20条评论。在最新的评论边上我们有一个\"显示全部\"的链接，点击后就可以获得更多的评论。我们假设数据库中的每条评论都有一个唯一的递增的ID字段。我们可以使用分页来制作主页和评论页，使用Redis的模板，每次新评论发表时，我们会将它的ID添加到一个Redis列表： LPUSH latest.comments 我们将列表裁剪为指定长度，因此Redis只需要保存最新的5000条评论： LTRIM latest.comments 0 5000 每次我们需要获取最新评论的项目范围时，我们调用一个函数来完成（使用伪代码）： FUNCTION get_latest_comments(start, num_items): id_list = redis.lrange(\"latest.comments\",start,start+num_items - 1) IF id_list.length 这里我们做的很简单。在Redis中我们的最新ID使用了常驻缓存，这是一直更新的。但是我们做了限制不能超过5000个ID，因此我们的获取ID函数会一直询问Redis。只有在start/count参数超出了这个范围的时候，才需要去访问数据库。我们的系统不会像传统方式那样“刷新”缓存，Redis实例中的信息永远是一致的。 SQL数据库（或是硬盘上的其他类型数据库）只是在用户需要获取“很远”的数据时才会被触发，而主页或第一个评论页是不会麻烦到硬盘上的数据库了。 2. 排行榜应用，取TOP N操作 这个需求与上面需求的不同之处在于，取最新N个数据的操作以时间为权重，这个是以某个条件为权重比如按顶的次数排序，这时候就需要我们的sorted set出马了，将你要排序的值设置成sorted set的score，将具体的数据设置成相应的value，每次只需要执行一条ZADD命令即可。 热门，排行榜应用： //将登录次数和用户统一存储在一个 sorted set里zadd login:login_times 5 1zadd login:login_times 1 2zadd login:login_times 2 3 //当用户登录时，对该用户的登录次数自增 1ret = r.zincrby(\"login:login_times\", 1, uid) //那么如何获得登录次数最多的用户呢，逆序排列取得排名前N的用户 ret = r.zrevrange(\"login:login_times\", 0, N-1) 另一个很普遍的需求是各种数据库的数据并非存储在内存中，因此在按得分排序以及实时更新这些几乎每秒钟都需要更新的功能上数据库的性能不够理想。典型的比如那些在线游戏的排行榜，比如一个Facebook的游戏，根据得分你通常想要： 列出前100名高分选手 列出某用户当前的全球排名 这些操作对于Redis来说小菜一碟，即使你有几百万个用户，每分钟都会有几百万个新的得分。模式是这样的，每次获得新得分时，我们用这样的代码： ZADD leaderboard 你可能用userID来取代username，这取决于你是怎么设计的。得到前100名高分用户很简单： ZREVRANGE leaderboard 0 99 用户的全球排名也相似，只需要： ZRANK leaderboard 3. 删除与过滤 我们可以使用LREM来删除评论。如果删除操作非常少，另一个选择是直接跳过评论条目的入口，报告说该评论已经不存在。 有些时候你想要给不同的列表附加上不同的过滤器。如果过滤器的数量受到限制，你可以简单的为每个不同的过滤器使用不同的Redis列表。毕竟每个列表只有5000条项目，但Redis却能够使用非常少的内存来处理几百万条项目。 4. 按照用户投票和时间排序 排行榜的一种常见变体模式就像Reddit或Hacker News用的那样，新闻按照类似下面的公式根据得分来排序：score = points / time^alpha 因此用户的投票会相应的把新闻挖出来，但时间会按照一定的指数将新闻埋下去。下面是我们的模式，当然算法由你决定。模式是这样的，开始时先观察那些可能是最新的项目，例如首页上的1000条新闻都是候选者，因此我们先忽视掉其他的，这实现起来很简单。每次新的新闻贴上来后，我们将ID添加到列表中，使用LPUSH + LTRIM，确保只取出最新的1000条项目。有一项后台任务获取这个列表，并且持续的计算这1000条新闻中每条新闻的最终得分。计算结果由ZADD命令按照新的顺序填充生成列表，老新闻则被清除。这里的关键思路是排序工作是由后台任务来完成的。 5. 处理过期项目 另一种常用的项目排序是按照时间排序。我们使用unix时间作为得分即可。 模式如下： 每次有新项目添加到我们的非Redis数据库时，我们把它加入到排序集合中。这时我们用的是时间属性，current_time和time_to_live。 另一项后台任务使用ZRANGE…SCORES查询排序集合，取出最新的10个项目。如果发现unix时间已经过期，则在数据库中删除条目。 6. 计数 Redis是一个很好的计数器，这要感谢INCRBY和其他相似命令。我相信你曾许多次想要给数据库加上新的计数器，用来获取统计或显示新信息，但是最后却由于写入敏感而不得不放弃它们。好了，现在使用Redis就不需要再担心了。有了原子递增（atomic increment），你可以放心的加上各种计数，用GETSET重置，或者是让它们过期。例如这样操作： INCR user: EXPIRE 你可以计算出最近用户在页面间停顿不超过60秒的页面浏览量，当计数达到比如20时，就可以显示出某些条幅提示，或是其它你想显示的东西。 7. 特定时间内的特定项目 另一项对于其他数据库很难，但Redis做起来却轻而易举的事就是统计在某段特点时间里有多少特定用户访问了某个特定资源。比如我想要知道某些特定的注册用户或IP地址，他们到底有多少访问了某篇文章。每次我获得一次新的页面浏览时我只需要这样做 SADD page:day1: 当然你可能想用unix时间替换day1，比如time()-(time()%3600*24)等等。 想知道特定用户的数量吗？只需要使用 SCARD page:day1: 8. 查找某个值所在的区间(区间无重合) Sorted Set-->例如有下面两个范围，10－20和30－40 A_start 10, A_end 20 B_start 30, B_end 40 我们将这两个范围的起始位置存在Redis的Sorted Sets数据结构中，基本范围起始值作为score，范围名加start和end为其value值： redis 127.0.0.1:6379> zadd ranges 10 A_start (integer) 1redis 127.0.0.1:6379> zadd ranges 20 A_end (integer) 1redis 127.0.0.1:6379> zadd ranges 30 B_start (integer) 1redis 127.0.0.1:6379> zadd ranges 40 B_end (integer) 1 这样数据在插入Sorted Sets后，相当于是将这些起始位置按顺序排列好了。现在我需要查找15这个值在哪一个范围中，只需要进行如下的zrangbyscore查找： redis 127.0.0.1:6379> zrangebyscore ranges (15 +inf LIMIT 0 1 1) \"A_end\" 这个命令的意思是在Sorted Sets中查找大于15的第一个值。（+inf在Redis中表示正无穷大，15前面的括号表示>15而非>=15）查找的结果是A_end，由于所有值是按顺序排列的，所以可以判定15是在A_start到A_end区间上，也就是说15是在A这个范围里。至此大功告成。 9. 交集，并集，差集：(Set) //book表存储book名称 set book:1:name ”The Ruby Programming Language” set book:2:name ”Ruby on rail” set book:3:name ”Programming Erlang” //tag表使用集合来存储数据，因为集合擅长求交集、并集 sadd tag:ruby 1sadd tag:ruby 2sadd tag:web 2sadd tag:erlang 3 //即属于ruby又属于web的书？ inter_list = redis.sinter(\"tag.web\", \"tag:ruby\") //即属于ruby，但不属于web的书？ inter_list = redis.sdiff(\"tag.ruby\", \"tag:web\") //属于ruby和属于web的书的合集？ inter_list = redis.sunion(\"tag.ruby\", \"tag:web\") "},"redis/redis-python.html":{"url":"redis/redis-python.html","title":"2.3. python-redis","keywords":"","body":"2.3 Redis应用场景 1、String 字符串 字符串类型是 Redis 最基础的数据结构，首先键都是字符串类型，而且 其他几种数据结构都是在字符串类型基础上构建的，我们常使用的 set key value 命令就是字符串。 常用在缓存、计数、共享Session、限速等。 2、Hash 哈希 在Redis中，哈希类型是指键值本身又是一个键值对 结构， 形如value={{field1，value1}，…{fieldN，valueN}}， 添加命令：hset key field value。 哈希可以用来存放用户信息，比如实现购物车 3、List 列表 列表（list）类型是用来存储多个有序的字符串。可以做简单的消息队列的功能。 另外，可以利用 lrange 命令，做基于 Redis的分页功能，性能极佳，用户体验好。 list是基于双向链表实现的，用于评论系统，新闻分页列表，消息队列等 4、Set 集合 集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一 样的是， 集合中不允许有重复元素，并且集合中的元素是无序的，不能通过 索引下标获取元素。 利用 Set 的交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。 5、Sorted Set 有序集合 Sorted Set 多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。 可以做排行榜应用，取 TOP N 操作 "},"redis/redis-python-str.html":{"url":"redis/redis-python-str.html","title":"2.3.1. redis-str","keywords":"","body":"2.3.1 python操作redis之string字符串 # -*- coding: utf-8 -*- import redis #这个redis 连接不能用，请根据自己的需要修改 r =redis.Redis(host=\"106.13.168.8\",port=6379,password=\"123456\") set 命令用于设置给定 key 的值。如果 key 已经存储其他值， SET 就覆写旧值，且无视类型。print r.set('123','123') # 插入成功后返回True print r.set('123','[123,dffd]') # 插入成功后返回True get 命令用于获取指定 key 的值。如果 key 不存在，返回 None 。如果key 储存的值不是字符串类型，返回一个错误。 print r.get('123') #返回的结果是[123,dffd] print r.get('1234')#返回的结果是 None getrange 命令用于获取存储在指定 key 中字符串的子字符串。字符串的截取范围由 start 和 end 两个偏移量决定(包括 start 和 end 在内)。print r.set('getrange','wo shi hao ren ') print r.getrange('getrange',2,4) #返回的结果是sh print r.getrange('getrange',2,6) #返回的结果是shi print r.getrange('getrange',2,10) #返回的结果是shi hao getset 命令用于设置指定 key 的值，并返回 key 旧的值当 key 存在但不是字符串类型时，返回一个错误。print r.getset('getrange','hello word') #返回的结果是wo shi hao ren print r.getset('getrange11','hello word') #当键不存在的时候，返回的结果是None getbit 命令用于对 key 所储存的字符串值，获取指定偏移量上的位(bit)字符串值指定偏移量上的位(bit)。当偏移量 getrange 比字符串值的长度大，或者 key 不存在时，返回 0。 print r.get('getrange') #返回的结果是 hello word print r.getbit('getrange',1) #返回的结果是 1 print r.getbit('getrange',3) #返回的结果是 0 print r.getbit('getr22222ange',3) #字符串的键不存在的时候返回的结果是 0 print r.getbit('getrange',300) #偏移量超过字符串长度，返回的结果是 0 mget 命令返回所有(一个或多个)给定 key 的值。 如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 Noneprint r.set('1','1') #返回的结果是 True print r.set('11','11') #返回的结果是 True print r.set('111','111') #返回的结果是 True print r.mget('1','11','111') #返回的结果是 ['1', '11', '111'] print r.mget('1','11','222222') #因为键222222不存在，返回的结果是 ['1', '11', None] setbit 命令用于对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。 print r.get('getrange') #返回的结果是 hello word print r.setbit('getrange',4,10086) #返回的结果是 1 print r.getbit('getrange',10086) #返回的结果是 0 print r.setbit('getrange',5,100861) #返回的结果是 0 print r.getbit('getrange',100861) #返回的结果是 0 setex 命令为指定的 key 设置值及其过期时间。如果 key 已经存在， setex 命令将会替换旧的值。 print r.setex('1','123',10) #返回的结果是 True import time time.sleep(5) print r.ttl('1') #返回的结果是 4 print r.get('1') #返回的结果是 123 time.sleep(6) print r.get('1') #返回的结果是 None setnx（SET if Not eXists） 命令在指定的 key 不存在时，为 key 设置指定的值。设置成功，返回 1 。 设置失败，返回 0 。print r.exists('22') #返回的结果是 False print r.setnx('22','2222222') #返回的结果是 True print r.setnx('22','123456') #返回的结果是 False print r.get('22') #返回的结果是 2222222 setrange 命令用指定的字符串覆盖给定 key 所储存的字符串值，覆盖的位置从偏移量 offset 开始。print r.set('11','hello world') #返回的结果是 True print r.setrange('11',6,\"redis\") #返回的结果是 11 print r.get('11') #返回的结果是 hello redis strlen 命令用于获取指定 key 所储存的字符串值的长度。当 key 储存的不是字符串值时，返回一个错误。print r.get('11') #返回的结果是 hello redis print r.strlen('11') #返回的结果是 11 print r.strlen('121') # 当key不存在的时候，返回的结果是 0 mset 命令用于同时设置一个或多个 key-value 对。第一种方法 print r.mset(name1=\"1\", name2='2') #返回的结果是 True 第二种方法 print r.mset({\"name3\":'3', \"name4\":'4'}) #返回的结果是 True print r.get('name1') #返回的结果是 1 print r.get('name2') #返回的结果是 2 print r.get('name3') #返回的结果是 3 print r.get('name4') #返回的结果是 4 metnx令用于所有给定 key 都不存在时，同时设置一个或多个 key-value 对。 当所有 key 都成功设置，返回 1 。 如果所有给定 key 都设置失败(至少有一个 key 已经存在)，那么返回 0 。 print r.msetnx(name5=\"5\", name6='6') #返回的结果是 True print r.msetnx(name5=\"55\", name7='7') #返回的结果是 False print r.get('name5') #返回的结果是 5 print r.get('name6') #返回的结果是 6 print r.get('name7') #返回的结果是 None psetex 命令以毫秒为单位设置 key 的生存时间。注意：SETEX 命令那样，以秒为单位。print r.psetex('name8',1000,\"nihao\") #返回的结果是 True print r.pttl('name8') #返回的结果是 690 print r.get('name8') #返回的结果是 nihao 时间过期后返回的是 None Incr 命令将 key 中储存的数字值增一 如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作。 如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。 本操作的值限制在 64 位(bit)有符号数字表示之内。print r.set('11',20) #返回的结果是 True print r.incr('11') #返回的结果是 21 print r.get('11') #返回的结果是 21 print r.incr('11',amount=2) #返回的结果是 23 print r.get('11') #返回的结果是 23 print r.incr('21',amount=2) #返回的结果是 2 print r.incr('22') #返回的结果是 1 Redis Incrby 命令将 key 中储存的数字加上指定的增量值。 如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCRBY 命令。 如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。 print r.set(\"13\",13) #返回的结果是 True print r.incrby('13',12) #返回的结果是 25 print r.incrby('15',12) #返回的结果是 12 print r.incrby('15',12) #返回的结果是 24 Redis Incrbyfloat 命令为 key 中所储存的值加上指定的浮点数增量值。 如果 key 不存在，那么 INCRBYFLOAT 会先将 key 的值设为 0 ，再执行加法操作。print r.set('1',1.1) #返回的结果是 True print r.incrbyfloat('1',2.32) #返回的结果是 3.42 print r.get('1') #返回的结果是 3.42 print r.incrbyfloat('1',amount=1.2) #返回的结果是 4.62 Redis Decr 命令将 key 中储存的数字值减一。 如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECR 操作。 如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。 本操作的值限制在 64 位(bit)有符号数字表示之内。print r.decr('22') #如果 key 22 不存在，返回的结果是 -1 print r.set('bb',20) #返回的结果是 True print r.decr('bb',amount=2) #返回的结果是 18 print r.decr('cc') #返回的结果是 -1 Redis Append 命令用于为指定的 key 追加值。 如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。 如果 key 不存在， APPEND 就简单地将给定 key 设为 value ，就像执行 SET key value 一样。 print r.set(\"11\",12) #返回的结果是 True print r.append('11',12) #返回的结果是 4 print r.append('11',1) #返回的结果是 5 print r.append('11',2) #返回的结果是 6 print r.get('11') #返回的结果是 121212 print r.exists('14') #返回的结果是 False print r.append('14','hello world') #返回的结果是 11 print r.get('14') #返回的结果是 hello world 转载:[blackball9](https://www.cnblogs.com/blackball9/p/11970358.html) "},"redis/redis-python-key.html":{"url":"redis/redis-python-key.html","title":"2.3.2. redis-key","keywords":"","body":"2.3.2 python操作redis之key键 # -*- coding: utf-8 -*- import redis #这个redis 连接不能用，请根据自己的需要修改 r =redis.Redis(host=\"106.13.168.8\",port=6379,password=\"123456\") delete del命令用于删除已存在的键。不存在的 key 会被忽略 # set 设置指定 key 的值,如果设置正确返回 True print r.set('1', '4028b2883d3f5a8b013d57228d760a93') print r.get('1') # 得到 键为1 的值 4028b2883d3f5a8b013d57228d760a93 print r.delete('1') # 删除 键为1 的值 print r.get('1') # 因为上面已经把键为1 的值删除掉，所以返回的是None exists # 设定键为2的值是 4028b2883d3f5a8b013d57228d760a93 r.set('2', '4028b2883d3f5a8b013d57228d760a93') # 存在就返回True 不存在就返回False print r.exists('2') #返回True print r.exists('33') #返回False Expire 命令用于设置 key 的过期时间。key 过期后将不再可用。 r.set('2', '4028b2883d3f5a8b013d57228d760a93') #成功就返回True 失败就返回False，下面的20表示是20秒 print r.expire('2',20) #如果时间没事失效我们能得到键为2的值，否者是None print r.get('2') Expireat命令用于以 UNIX 时间戳(unix timestamp)格式设置 key 的过期时间。key 过期后将不再可用。注意:时间精确到秒，时间戳是10为数字 r.set('2', '4028b2883d3f5a8b013d57228d760a93') #成功就返回True 失败就返回False，下面的1598033936表示是在2020-08-22 02:18:56 键2 过期 print r.expireat('2',1598033936) print r.get('2') PEXPIREAT 命令用于设置 key 的过期时间，已毫秒技。key 过期后将不再可用。注意:时间精确到毫秒，时间戳是13位数字 r.set('2', '4028b2883d3f5a8b013d57228d760a93') #成功就返回True 失败就返回False。 print r.expireat('2',1598033936000) print r.get('2') Keys 命令用于查找所有符合给定模式 pattern 的 key print r.set('111', '11') print r.set('122', '12') print r.set('113', '13') print r.keys(pattern='11*') # 输出的结果是 ['113', '111'] 因为键122不和 11* 匹配 MOVE 命令用于将当前数据库的 key 移动到给定的数据库 db 当中,select可以设定当前的数据库，如有需要请看select命令因为我们默认使用的数据库是db0，我们可以使用下面的命令键 2 移动到数据库 1 中去 # 将select 0 key 为 2 转存到 select 1 r.move(2,1) PERSIST 命令用于移除给定 key 的过期时间，使得 key 永不过期 #设定键为 1 的值为11 print r.set('1', '11') #设定键 1 过期时间为100秒 print r.expire(1,100) # 查看键 1 的过期时间还剩下多少 print r.ttl('1') # 目的是13秒后移除键 1 的过期时间 import time time.sleep(3) # 查看键 1 的过期时间还剩下多少 print r.ttl('1') #移除键 1 的过期时间 r.persist(1) # 查看键 1 的过期时间还剩下多少 输出的结果是 None # 我们可以通过redis desktop manager 查看键 1 的过期时间 print r.ttl('1') Pttl 命令以毫秒为单位返回 key 的剩余过期时间。 # 当 key 不存在时，返回 -2 。 # 当 key 存在但没有设置剩余生存时间时，返回 -1 。 # 否则，以毫秒为单位，返回 key 的剩余生存时间。 #设定键为 1 的值为11 print r.set('1', '11') #设定键 1 过期时间为100秒 print r.expire(1,100) import time time.sleep(3) # 返回的结果是 96994 ，运行的结果不是固定的，大于是97秒钟， # 注意是为了展示出返回的结果是毫秒，一秒等于1000毫秒 print r.pttl('1') TTL 命令以秒为单位返回 key 的剩余过期时间。 # 当 key 不存在时，返回 -2 。 # 当 key 存在但没有设置剩余生存时间时，返回 -1 。 # 否则，以毫秒为单位，返回 key 的剩余生存时间。 # 设定键为 1 的值为11 print r.set('1', '11') # 设定键 1 过期时间为100秒 print r.expire(1,100) import time time.sleep(3) print r.ttl('1') #返回的结果是 97 print r.ttl('123') #因为键 123 不存在 所以返回的结果是None RANDOMKEY 命令从当前数据库中随机返回一个 key。当数据库不为空时，返回一个 key 。 当数据库为空时，返回 nil 。 print r.randomkey() # 数据库返回的是默认的数据库 key Rename 命令用于修改 key 的名称 。改名成功时提示 OK ，失败时候返回一个错误。 print r.rename(1,1111) #修改成功返回 True #如果key 不存在 修改失败返回 redis.exceptions.ResponseError: no such key print r.rename(222,1111) Renamenx 命令用于在新的 key 不存在时修改 key 的名称 。 print r.exists(123123) #返回false print r.renamenx(1111,123123) #成功返回True #失败返回 redis.exceptions.ResponseError: no such key print r.renamenx(1111,123123) Type 命令用于返回 key 所储存的值的类型 # 返回 key 的数据类型，数据类型有：none (key不存在)，string (字符串)，list (列表)，set (集合)，zset (有序集)，hash (哈希表)， print r.set('1',\"111111111\") print r.type('1') #返回的结果是string print r.sadd('2','222222222222') print r.type('2') #返回的结果是set print r.lpush('3','33333333') print r.type('3') #返回的结果是list 命令 描述 redis del 命令 该命令用于在 key 存在是删除 key。 redis dump 命令 序列化给定 key ，并返回被序列化的值。 redis exists 命令 检查给定 key 是否存在。 redis expire 命令 seconds 为给定 key 设置过期时间。 redis expireat 命令 expireat 的作用和 expire 类似，都用于为 key 设置过期时间。不同在于 expireat 命令接受的时间参数是 unix 时间戳(unix timestamp)。 redis pexpireat 命令 设置 key 的过期时间亿以毫秒计。 redis pexpireat 命令 设置 key 过期时间的时间戳(unix timestamp) 以毫秒计 redis keys 命令 查找所有符合给定模式( pattern)的 key 。 redis move 命令 将当前数据库的 key 移动到给定的数据库 db 当中。 redis persist 命令 移除 key 的过期时间，key 将持久保持。 redis pttl 命令 以毫秒为单位返回 key 的剩余的过期时间。 redis ttl 命令 以秒为单位，返回给定 key 的剩余生存时间(ttl, time to live)。 redis randomkey 命令 从当前数据库中随机返回一个 key 。 redis rename 命令 修改 key 的名称 redis renamenx 命令 仅当 newkey 不存在时，将 key 改名为 newkey 。 redis type 命令 返回 key 所储存的值的类型。   转载 blackball9 原文链接 "},"redis/redis-python-hash.html":{"url":"redis/redis-python-hash.html","title":"2.3.3. redis-hash","keywords":"","body":"2.3.3 python操作redis之Hash哈希 # -*- coding: utf-8 -*- import redis #这个redis不能用，请根据自己的需要修改 r =redis.Redis(host=\"106.13.168.8\",port=6379,password=\"123456\") Hset 命令用于为哈希表中的字段赋值 。如果哈希表不存在，一个新的哈希表被创建并进行 HSET 操作。如果字段已经存在于哈希表中，旧值将被覆盖。 如果字段是哈希表中的一个新建字段，并且值设置成功，返回 1 。 如果哈希表中域字段已经存在且旧值已被新值覆盖，返回 0 。 print r.hset(name=\"name\",key=\"key1\",value=\"value\") #返回的结果是 1 print r.hget(name=\"name\",key=\"key1\") #返回的结果是 value #返回的结果是 0,原因是哈希表中域字段已经存在且旧值已被新值覆盖 print r.hset(name=\"name\",key=\"key1\",value=\"hello world\") print r.hget(name=\"name\",key=\"key1\") #返回的结果是 hello world Hdel 命令用于删除哈希表 key 中的一个或多个指定字段，不存在的字段将被忽略。print r.hset(name=\"1\", key=\"1\", value=\"1\") # 返回的结果是 1 print r.delete(1) # 删除成功后 返回的结果是 1 print r.delete(1) # 因为上一步已经删除，删除失败后 返回的结果是 0 Hexists 命令用于查看哈希表的指定字段是否存在。如果哈希表含有给定字段，返回 True 。 如果哈希表不含有给定字段，或 key 不存在，返回False 。print r.hset(name=\"1\", key=\"1\", value=\"1\") # 返回的结果是 1 print r.hexists(name=\"1\",key=\"1\") # 返回的结果是 True print r.hexists(name=\"1\",key=\"2\") # 返回的结果是 False print r.hexists(name=\"2\",key=\"2\") # 返回的结果是 False print r.hexists(name=\"2\",key=\"1\") # 返回的结果是 False Hget 命令用于返回哈希表中指定字段的值。返回给定字段的值。如果给定的字段或 key 不存在时，返回 None 。print r.hset(name=\"1\", key=\"1\", value=\"1\") # 返回的结果是 1 print r.hget(\"1\",\"1\") # 返回的结果是 1 print r.hget(\"2\",\"1\") # 因为字段2不存在。所以返回的结果是 None print r.hget(\"1\",\"2\") # 因为key 2 不存在。所以返回的结果是 None print r.hget(\"2\",\"2\") # 因为key和字段都不存在，所以返回的结果是 None Hgetall 命令用于返回哈希表中，所有的字段和值。在返回值里，紧跟每个字段名(field name)之后是字段的值(value)，所以返回值的长度是哈希表大小的两倍。 print r.hset(name=\"1\", key=\"1\", value=\"1\") # 返回的结果是 1 print r.hset(name=\"1\", key=\"3\", value=\"2\") # 返回的结果是 1 print r.hset(name=\"1\", key=\"2\", value=\"3\") # 返回的结果是 1 print r.hset(name=\"1\", key=\"2\", value=\"4\") # 返回的结果是 0 print r.hgetall(\"1\") # 返回的结果是 {'1': '1', '3': '2', '2': '4'} 主意返回的数据格式 print r.hgetall(\"2\") # 因为字典名2 不存在，所以返回的结果是 {} Hincrby 命令用于为哈希表中的字段值加上指定增量值。 增量也可以为负数，相当于对指定字段进行减法操作。 如果哈希表的 key 不存在，一个新的哈希表被创建并执行 HINCRBY 命令。 如果指定的字段不存在，那么在执行命令前，字段的值被初始化为 0 。 对一个储存字符串值的字段执行 HINCRBY 命令将造成一个错误。print r.hincrby(name=\"1\",key=\"1\",amount=2) # 返回的结果是 3 print r.hget(name=\"1\",key=\"1\") # 返回的结果是 3 print r.hincrby(name=\"2\", key=\"2\", value=\"3\") 字段不存在，返回的结果是 TypeError: hincrby() got an unexpected keyword argument 'value' print r.hincrby(name=\"1\",key=\"2\",amount=4) key为2不存在，返回的结果是 4，说明哈希表的 key 不存在，一个新的哈希表被创建并执行 HINCRBY 命令 print r.hget(name=\"1\",key=\"2\") # 返回的结果是 4 Hincrbyfloat 命令用于为哈希表中的字段值加上指定浮点数增量值。 如果指定的字段不存在，那么在执行命令前，字段的值被初始化为 0 。print r.hset(name=\"1\", key=\"1\", value=\"1\") # 返回的结果是 1 print r.hincrbyfloat(name=\"1\",key=\"1\",amount=\"1.2\") # 返回的结果是 2.2 print r.hget(\"1\",\"1\") # 返回的结果是 2.2 print r.hincrbyfloat(name=\"2\",key=\"1\",amount=\"1.2\") 指定的字段2不存在，返回的结果是 1.2，说明如果指定的字段不存在，那么在执行命令前，字段的值被初始化为 0 Hkeys 命令用于获取哈希表中的所有字段名。包含哈希表中所有字段的列表。 当 key 不存在时，返回一个空列表。print r.hset(name=\"1\", key=\"1\", value=\"1\") # 返回的结果是 1 print r.hset(name=\"1\", key=\"1\", value=\"2\") # 返回的结果是 0 print r.hset(name=\"1\", key=\"2\", value=\"2\") # 返回的结果是 1 print r.hset(name=\"1\", key=\"3\", value=\"2\") # 返回的结果是 1 print r.hkeys(1) # 返回的结果是 ['1', '2', '3'] print r.hkeys(2) # 因为指定的字段名不存在，所以返回的结果是 [] >Hlen 命令用于获取哈希表中字段的数量。哈希表中字段的数量。 当 key 不存在时，返回 0 。print r.hset(name=\"1\", key=\"1\", value=\"1\") # 返回的结果是 1 print r.hset(name=\"1\", key=\"2\", value=\"2\") # 返回的结果是 1 print r.hlen(1) # 返回的结果是 2 print r.hset(name=\"1\", key=\"4\", value=\"3\") # 返回的结果是 1 print r.hset(name=\"1\", key=\"3\", value=\"2\") # 返回的结果是 1 print r.hlen(1) # 返回的结果是 4 Hmget 命令用于返回哈希表中，一个或多个给定字段的值。如果指定的字段不存在于哈希表，那么返回一个 nil 值。 一个包含多个给定字段关联值的表，表值的排列顺序和指定字段的请求顺序一样。print r.hset(name=\"1\", key=\"1\", value=\"1\") # 返回的结果是 1 print r.hset(name=\"1\", key=\"2\", value=\"2\") # 返回的结果是 1 print r.hmget(name=\"1\",keys=\"1\") # 返回的结果是 ['1'] print r.hmget(name=\"1\",keys=\"2\") # 返回的结果是['2'] print r.hmget(name=\"2\",keys=\"1\") # 返回的结果是 [None] Hmset 命令用于同时将多个 field-value (字段-值)对设置到哈希表中。 此命令会覆盖哈希表中已存在的字段。 如果哈希表不存在，会创建一个空哈希表，并执行 HMSET 操作。aa = {\"a\":\"a\",\"b\":\"b\"} # 返回的结果是 ['1'] print r.hmset(\"name\",aa) # 返回的结果是 True print r.hget(name=\"name\",key=\"a\") # 返回的结果是 a print r.hget(name=\"name\",key=\"b\") # 返回的结果是 b Hsetnx 命令用于为哈希表中不存在的的字段赋值 。 如果哈希表不存在，一个新的哈希表被创建并进行 HSET 操作。 如果字段已经存在于哈希表中，操作无效。 如果 key 不存在，一个新哈希表被创建并执行 HSETNX 命令。 设置成功，返回 1 。 如果给定字段已经存在且没有操作被执行，返回 0 。print r.hsetnx(name=\"1\",key=\"1\",value=\"1\") # 返回的结果是 1 print r.hsetnx(name=\"1\",key=\"1\",value=\"2\") # 返回的结果是 0 print r.hsetnx(name=\"2\",key=\"1\",value=\"2\") # 返回的结果是 0 Hvals 命令返回哈希表所有字段的值。一个包含哈希表中所有值的表。 当 key 不存在时，返回一个空表。print r.hset(name=\"1\", key=\"1\", value=\"11\") # 返回的结果是 1 print r.hset(name=\"1\", key=\"2\", value=\"22\") # 返回的结果是 1 print r.hset(name=\"1\", key=\"3\", value=\"33\") # 返回的结果是 1 print r.hset(name=\"1\", key=\"4\", value=\"44\") # 返回的结果是 1 print r.hvals(\"1\") # 返回的结果是 ['11', '22', '33', '44'] print r.hvals(\"2\") # 返回的结果是 [] 附录： 命令 描述 redis hdel 命令 删除一个或多个哈希表字段 redis hexists 命令 查看哈希表 key 中，指定的字段是否存在。 redis hget 命令 获取存储在哈希表中指定字段的值/td> redis hgetall 命令 获取在哈希表中指定 key 的所有字段和值 redis hincrby 命令 为哈希表 key 中的指定字段的整数值加上增量 increment 。 redis hincrbyfloat 命令 为哈希表 key 中的指定字段的浮点数值加上增量 increment 。 redis hkeys 命令 获取所有哈希表中的字段 redis hlen 命令 获取哈希表中字段的数量 redis hmget 命令 获取所有给定字段的值 redis hmset 命令 同时将多个 field-value (域-值)对设置到哈希表 key 中。 redis hset 命令 将哈希表 key 中的字段 field 的值设为 value 。 redis hsetnx 命令 只有在字段 field 不存在时，设置哈希表字段的值。 redis hvals 命令 获取哈希表中所有值 "},"redis/redis-python-list.html":{"url":"redis/redis-python-list.html","title":"2.3.4. redis-list","keywords":"","body":"2.3.4 python操作redis之list列表 # -*- coding: utf-8 -*- import redis r =redis.Redis(host=\"106.13.168.8\",port=6379,password=\"123456\") Lpush 命令将一个或多个值插入到列表头部。 如果 key 不存在，一个空列表会被创建并执行 LPUSH 操作。 当 key 存在但不是列表类型时，返回一个错误。 执行 LPUSH 命令后，列表的长度。 print r.lpush(\"1\",1) #输出的结果是1 print r.lpush(\"1\",1) #输出的结果是2 print r.lpush(\"1\",2,3,4) #输出的结果是5 print r.set(\"2\",1) #输出的结果是 True print r.lpush(\"2\",2) #输出的结果是 redis.exceptions.ResponseError: WRONGTYPE Operation against a key holding the wrong kind of value, 原因是键 2 是字符串类型，我们用list中的lpush给他添加元素 Rpush 命令用于将一个或多个值插入到列表的尾部(最右边)。 如果列表不存在，一个空列表会被创建并执行 RPUSH 操作。 当列表存在但不是列表类型时，返回一个错误。 执行 RPUSH 操作后，列表的长度。 print r.rpush(\"2\",1) #输出的结果是1 print r.rpush(\"2\",2,3) #输出的结果是3 print r.rpush(\"2\",4,5) #输出的结果是5 数据格式： Blpop 命令移出并获取列表的第一个元素 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 如果列表为空，返回一个 None 。 否则，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。 print r.rpush(\"3\",1,2,3,4,5,6,) #输出的结果是6 print r.blpop(\"3\") #输出的结果是('3', '1') print r.blpop(\"3\") #输出的结果是('3', '2') print r.blpop(\"3\") #输出的结果是('3', '3') print r.blpop(\"4\",timeout=2) #因为键 4 不存在，所以2秒后输出的结果是None Brpop 命令移出并获取列表的最后一个元素如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 假如在指定时间内没有任何元素被弹出，则返回一个None 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。 print r.rpush(\"4\",1,2,3,4,5,6,) #输出的结果是6 print r.brpop(\"4\") #输出的结果是('4', '6') print r.brpop(\"4\") #输出的结果是('4', '5') print r.brpop(\"4\") #输出的结果是('4', '4') print r.brpop(\"5\",timeout=2) #因为键 4 不存在，所以2秒后输出的结果是None Brpoplpush 命令从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 假如在指定时间内没有任何元素被弹出，则返回一个 None 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素的值，第二个元素是等待时长。 print r.rpush(\"11\",1,2,3) #输出的结果是3 print r.rpush(\"22\",4,5,6,) #输出的结果是3 print r.brpoplpush(src=\"11\",dst=\"22\",timeout=2) #输出的结果是3 print r.brpoplpush(src=\"44\",dst=\"22\",timeout=2) #键44 不存在，输出的结果是None Lindex 命令用于通过索引获取列表中的元素。你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。 列表中下标为指定索引值的元素。 如果指定索引值不在列表的区间范围内，返回 None 。 print r.rpush(\"6\",1,2,3) #输出的结果是3 print r.lindex(\"6\",1) #输出的结果是2 print r.lindex(\"6\",2) #输出的结果是3 print r.lindex(\"6\",3) #输出的结果是None print r.lindex(\"6\",4) #输出的结果是None print r.lindex(\"6\",-1) #输出的结果是3 Linsert 命令用于在列表的元素前或者后插入元素。 当指定元素不存在于列表中时，不执行任何操作。 当列表不存在时，被视为空列表，不执行任何操作。如果 key 不是列表类型，返回一个错误。 如果命令执行成功，返回插入操作完成之后，列表的长度。如果没有找到指定元素 ，返回 -1 。如果 key 不存在或为空列表，返回 0 。 print r.rpush(\"7\",1) #输出的结果是1 print r.rpush(\"7\",2) #输出的结果是2 print r.linsert(\"7\",\"BEFORE\",\"2\",12) #输出的结果是2 Llen 命令用于返回列表的长度。 如果列表 key 不存在，则 key 被解释为一个空列表，返回 0 。 如果 key 不是列表类型，返回一个错误。 print r.llen(\"8\") #key 不存在，输出的结果是0 print r.rpush(\"8\",1) #输出的结果是1 print r.llen(\"8\") #输出的结果是1 print r.rpush(\"8\",2,3) #输出的结果是3 print r.llen(\"8\") #输出的结果是3 Lpop 命令用于移除并返回列表的第一个元素。列表的第一个元素。 当列表 key 不存在时，返回 None 。 print r.lpop(\"9\") #输出的结果是None print r.rpush(\"9\",1) #输出的结果是1 print r.rpush(\"9\",2) #输出的结果是2 print r.lpop(\"9\") #输出的结果是1 说明：被移除掉的是第一个值 1, 值2没有被移除 Lpushx 将一个或多个值插入到已存在的列表头部，列表不存在时操作无效。 print r.rpush(\"10\",1) #输出的结果是1 print r.rpushx(\"10\",2) #输出的结果是2 print r.rpushx(\"10\",3) #输出的结果是3 print r.rpushx(\"11\",3) #输出的结果是5 print r.lrange(\"10\",0,-1) #输出的结果是['1', '2', '3'] print r.lrange(\"11\",0,-1) #输出的结果是['1', '2', '1', '2', '3'] Lrange 返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定。 其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。 print r.rpush(\"11\",3,4) #输出的结果是4 print r.lrange(\"11\",0,-1) #输出的结果是['1', '2', '3', '4'] print r.lrange(\"11\",1,2) #输出的结果是['2', '3'] Lrem 根据参数 COUNT 的值，移除列表中与参数 VALUE 相等的元素。 COUNT 的值可以是以下几种： count > 0 : 从表头开始向表尾搜索，移除与 VALUE 相等的元素，数量为 COUNT 。 count count = 0 : 移除表中所有与 VALUE 相等的值。 被移除元素的数量。 列表不存在时返回 0 。 print r.rpush(\"12\", 1) # 输出的结果是1 print r.rpush(\"12\", 1) # 输出的结果是2 print r.rpush(\"12\", 2) # 输出的结果是3 print r.rpush(\"12\", 1) # 输出的结果是4 print r.lrem(\"12\",1,-2) # 输出的结果是2 print r.lrange(\"12\",0,-1) # 输出的结果是['1', '2'] Lset 通过索引来设置元素的值。 当索引参数超出范围，或对一个空列表进行 LSET 时，返回一个错误 操作成功返回 True ，否则返回错误信息。print r.rpush(\"13\",1,2,3,4) # 输出的结果是4 print r.lset(\"13\",1,5) # 输出的结果是True print r.lrange(\"13\",0,-1) # 输出的结果是['1', '5', '3', '4'] Ltrim 对一个列表进行修剪(trim), 让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。 下标 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。print r.rpush(\"14\",1,2,3,4) # 输出的结果是4 print r.ltrim(\"14\",1,-2) # 输出的结果是True print r.lrange(\"14\",0,-1) # 输出的结果是['2', '3'] Rpop 命令用于移除并返回列表的最后一个元素。列表的最后一个元素。 当列表不存在时，返回 None 。print r.rpush(\"15\",1,2,3,4) # 输出的结果是4 print r.rpop(\"15\") # 输出的结果是4 print r.lrange(\"15\",0,-1) # 输出的结果是['1', '2', '3'] Rpoplpush 命令用于移除列表的最后一个元素，并将该元素添加到另一个列表并返回。print r.rpush(\"16\",1,2,3,4) # 输出的结果是4 print r.rpush(\"17\",1,2,3,4) # 输出的结果是4 print r.rpoplpush(\"16\",\"17\") # 输出的结果是4 print r.lrange(\"16\",0,-1) # 输出的结果是['1', '2', '3'] print r.lrange(\"17\",0,-1) # 输出的结果是['4', '1', '2', '3', '4'] Rpushx 命令用于将一个或多个值插入到已存在的列表尾部(最右边)。如果列表不存在，操作无效。print r.rpushx(\"18\",1) # 因为键18 不存在，所以插入失败，输出的结果是0 print r.rpush(\"18\",2) # 输出的结果是1 print r.rpushx(\"18\",3) # 输出的结果是2 print r.lrange(\"18\",0,-1) # 输出的结果是['2', '3'] 附录： 命令描述 redis blpop 命令 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 redis brpop 命令 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 redis brpoplpush 命令 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 redis lindex 命令 通过索引获取列表中的元素 redis linsert 命令 在列表的元素前或者后插入元素 redis llen 命令 获取列表长度 redis lpop 命令 移出并获取列表的第一个元素 redis lpush 命令 将一个或多个值插入到列表头部 redis lpushx 命令 将一个或多个值插入到已存在的列表头部 redis lrange 命令 获取列表指定范围内的元素 redis lrem 命令 移除列表元素 redis lset 命令 通过索引设置列表元素的值 redis ltrim 命令 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。 redis rpop 命令 移除并获取列表最后一个元素 redis rpoplpush 命令 移除列表的最后一个元素，并将该元素添加到另一个列表并返回 redis rpush 命令 在列表中添加一个或多个值 redis rpushx 命令 为已存在的列表添加值 "},"redis/redis-python-set.html":{"url":"redis/redis-python-set.html","title":"2.3.5. redis-set","keywords":"","body":"2.3.5 python操作redis之set集合 -*- coding: utf-8 -*- import redis r =redis.Redis(host=\"106.13.168.8\",port=6379,password=\"123456\") Sadd 命令将一个或多个成员元素加入到集合中，已经存在于集合的成员元素将被忽略。 假如集合 key 不存在，则创建一个只包含添加的元素作成员的集合。当集合 key 不是集合类型时，返回一个错误。 print r.sadd(\"1\",1) #输出的结果是1 print r.sadd(\"1\",2) #输出的结果是1 print r.sadd(\"1\",2) #因为2已经存在，不能再次田间，所以输出的结果是0 print r.sadd(\"1\",3,4) #输出的结果是2 print r.sinter(\"1\") #输出的结果是set(['1', '3', '2', '4']) Scard 命令返回集合中元素的数量。集合的数量。当集合 key 不存在时，返回 0 。 print r.sadd(\"2\",1) #输出的结果是1 print r.sadd(\"2\",2,3,4,5) #输出的结果是4 print r.scard(\"2\") #输出的结果是5 Sdiff 命令返回给定集合之间的差集。不存在的集合 key 将视为空集。 print r.sadd(\"31\",1,2,3,4,5,6) #输出的结果是6 print r.sadd(\"32\",4,5,6,7,8,9) #输出的结果是6 print r.sdiff(31,32) #输出的结果是set(['1', '3', '2']) 在31不在32内元素 print r.sdiff(32,31) #输出的结果是set(['9', '8', '7']) 在32不在31内元素 print r.sdiff(31,31) #输出的结果是set([]) Sdiffstore 命令将给定集合之间的差集存储在指定的集合中。如果指定的集合 key 已存在，则会被覆盖。 print r.sadd(\"41\",1,2,3,4,5,6) #输出的结果是6 print r.sadd(\"42\",4,5,6,7,8,9) #输出的结果是6 print r.sadd(\"43\",0) #输出的结果是1 print r.sdiffstore(\"43\",\"41\",\"42\") #输出的结果是3 覆盖原来的43的元素 print r.sinter(\"43\") #输出的结果是 set(['1', '3', '2']) Sinter 命令返回给定所有给定集合的交集。 不存在的集合 key 被视为空集。 当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。 print r.sadd(\"51\",3,4,5,6) #输出的结果是4 print r.sadd(\"52\",1,2,3,4) #输出的结果是4 print r.sinter(51,52) #输出的结果是set(['3', '4']) print r.sadd(\"53\",1,2,3,4,5,6) #输出的结果是6 print r.sadd(\"54\",3,4,5,6,7,8,9)#输出的结果是7 print r.sinter(53,54) #输出的结果是set(['3', '5', '4', '6']) print r.sinter(53,56) #输出的结果是set([]) Sinterstore 命令将给定集合之间的交集存储在指定的集合中。如果指定的集合已经存在，则将其覆盖。 print r.sadd(\"61\",3,4,5,6) #输出的结果是4 print r.sadd(\"62\",1,2,3,4) #输出的结果是4 print r.sadd(\"63\",0) #输出的结果是1 print r.sinterstore(63,61,62) #输出的结果是2 print r.sinter(63) #输出的结果是set(['3', '4']) Sismember 命令判断成员元素是否是集合的成员。 如果成员元素是集合的成员，返回 1 。 如果成员元素不是集合的成员，或 key 不存在，返回 0 。 print r.sadd(\"71\",1,2,3,4,5,6) #输出的结果是6 print r.sismember(\"71\",1) #输出的结果是True print r.sismember(\"71\",2) #输出的结果是True print r.sismember(\"71\",7) #输出的结果是False print r.sismember(\"71\",8) #输出的结果是False Smembers 命令返回集合中的所有的成员。 不存在的集合 key 被视为空集合。 print r.sadd(\"81\",1,2,3,4,5,6) #输出的结果是6 print r.smembers(81) #输出的结果是set(['1', '3', '2', '5', '4', '6']) print r.smembers(82) #输出的结果是set([]) Smove 命令将指定成员 member 元素从 source 集合移动到 destination 集合。 SMOVE 是原子性操作。如果 source 集合不存在或不包含指定的 member 元素，则 SMOVE 命令不执行任何操作，仅返回 False 。否则， member 元素从 source 集合中被移除，并添加到 destination 集合中去。 当 destination 集合已经包含 member 元素时， SMOVE 命令只是简单地将 source 集合中的 member 元素删除。 当 source 或 destination 不是集合类型时，返回一个错误。 如果成员元素被成功移除，返回 True。 如果成员元素不是 source 集合的成员，并且没有任何操作对 destination 集合执行，那么返回 False print r.sadd(\"91\",1,2,) #输出的结果是2 print r.sadd(\"92\",3,4,) #输出的结果是2 print r.smove(91,92,1) #把91中的1移动到92中去，输出的结果是True print r.smembers(\"91\") #输出的结果是set(['2']) print r.smembers(\"92\") #输出的结果是set(['1', '3', '4']) print r.smove(91,92,5) #91不存在5，输出的结果是False print r.smembers(\"91\") #输出的结果是set(['2']) print r.smembers(\"92\") #输出的结果是set(['1', '3', '4']) Spop 命令用于移除并返回集合中的一个随机元素。 print r.sadd(\"10\",1,2,3,4,5,6) #输出的结果是6 print r.spop(\"10\") #输出的结果是3 print r.smembers(\"10\") #输出的结果是set(['1', '2', '5', '4', '6']) print r.spop(\"10\") #输出的结果是1 print r.smembers(\"10\") #输出的结果是set(['2', '5', '4', '6']) Srandmember 命令用于返回集合中的一个随机元素。 从 Redis 2.6 版本开始， Srandmember 命令接受可选的 count 参数： 如果 count 为正数，且小于集合基数，那么命令返回一个包含 count 个元素的数组，数组中的元素各不相同。如果 count 大于等于集合基数，那么返回整个集合。 如果 count 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 count 的绝对值。 该操作和 SPOP 相似，但 SPOP 将随机元素从集合中移除并返回，而 Srandmember 则仅仅返回随机元素，而不对集合进行任何改动。 print r.sadd(\"11\",1,2,3,4,5,6) #输出的结果是6 print r.srandmember(11) #输出的结果是4 print r.smembers(11) #输出的结果是set(['1', '3', '2', '5', '4', '6']) print r.srandmember(11,3) #输出的结果是['6', '3', '1'] print r.smembers(11) #输出的结果是set(['1', '3', '2', '5', '4', '6']) Srem 命令用于移除集合中的一个或多个成员元素，不存在的成员元素会被忽略。 当 key 不是集合类型，返回一个错误。被成功移除的元素的数量，不包括被忽略的元素。 print r.sadd(\"12\",1,2,3,4,5,6,7) #输出的结果是7 print r.srem(\"12\",1) #输出的结果是1 print r.smembers(\"12\") #输出的结果是set(['3', '2', '5', '4', '7', '6']) print r.srem(\"12\",8) #输出的结果是0 print r.smembers(\"12\") #输出的结果是set(['3', '2', '5', '4', '7', '6']) Sunion 命令返回给定集合的并集。不存在的集合 key 被视为空集。 print r.sadd(\"131\",1,2,3,4,5,6,7) #输出的结果是7 print r.sadd(\"132\",0,1,2,7,8,9) #输出的结果是6 print r.sunion(131,132) #输出的结果是set(['1', '0', '3', '2', '5', '4', '7', '6', '9', '8']) print r.sunion(131,134) #输出的结果是set(['1', '3', '2', '5', '4', '7', '6']) Sunionstore 命令将给定集合的并集存储在指定的集合 destination 中。 print r.sadd(\"141\",1,2,3,4,5,6,7) #输出的结果是7 print r.sadd(\"142\",0,1,2,3,4) #输出的结果是5 print r.sunionstore(143,141,142) #输出的结果是8 print r.smembers(143) #输出的结果是set(['1', '0', '3', '2', '5', '4', '7', '6']) Sscan 命令用于迭代集合键中的元素。 print r.sadd(\"151\",1,2,3,4,5,6,7) #输出的结果是7 print r.sscan(151,cursor=2,match=1,count=1) #输出的结果是 (0L, ['1']) 附录： 命令描述 redis sadd 命令 向集合添加一个或多个成员 redis scard 命令 获取集合的成员数 redis sdiff 命令 返回给定所有集合的差集 redis sdiffstore 命令 返回给定所有集合的差集并存储在 destination 中 redis sinter 命令 返回给定所有集合的交集 redis sinterstore 命令 返回给定所有集合的交集并存储在 destination 中 redis sismember 命令 判断 member 元素是否是集合 key 的成员 redis smembers 命令 返回集合中的所有成员 redis smove 命令 将 member 元素从 source 集合移动到 destination 集合 redis spop 命令 移除并返回集合中的一个随机元素 redis srandmember 命令 返回集合中一个或多个随机数 redis srem 命令 移除集合中一个或多个成员 redis sunion 命令 返回所有给定集合的并集 redis sunionstore 命令 所有给定集合的并集存储在 destination 集合中 redis sscan 命令 迭代集合中的元素 "},"redis/redis-python-zset.html":{"url":"redis/redis-python-zset.html","title":"2.3.6. redis-zset","keywords":"","body":"2.3.6 python操作redis之sorted set有序集合 #coding:utf8 import redis r =redis.Redis(host=\"106.13.168.8\",port=6379,password=\"123456\") Zadd 命令用于将一个或多个成员元素及其分数值加入到有序集当中。 如果某个成员已经是有序集的成员，那么更新这个成员的分数值，并通过重新插入这个成员元素，来保证该成员在正确的位置上。 分数值可以是整数值或双精度浮点数。 如果有序集合 key 不存在，则创建一个空的有序集并执行 ZADD 操作。 当 key 存在但不是有序集类型时，返回一个错误。 print r.zadd(\"1\",\"1\",2,\"3\",3) #输出的结果是2 print r.zadd(\"1\",\"2\",2) #输出的结果是1 print r.zadd(\"1\",\"1\",1) #输出的结果是0 print r.zadd(\"1\",\"3\",4) #输出的结果是0 print r.zrange(\"1\",0,-1) #输出的结果是 ['1', '2', '3'] Zcard 命令用于计算集合中元素的数量。 当 key 存在且是有序集类型时，返回有序集的基数。当 key 不存在时，返回 0 。 print r.zadd(\"1\",\"1\",1,\"3\",3) #输出的结果是2 print r.zadd(\"1\",\"2\",2) #输出的结果是1 print r.zadd(\"1\",\"2\",4) #输出的结果是1 print r.zcard(1) #输出的结果是3 print r.zcard(2) #输出的结果是0 Zcount 命令用于计算有序集合中指定分数区间的成员数量。分数值在 min 和 max 之间的成员的数量。 print r.zadd(\"2\",\"1\",1,\"3\",3) #输出的结果是2 print r.zadd(\"2\",\"2\",2) #输出的结果是1 print r.zadd(\"2\",\"1\",4) #输出的结果是0 print r.zcount(\"2\",min=0,max=5) #输出的结果是3 print r.zcount(\"2\",min=0,max=3) #输出的结果是2 print r.zcount(\"2\",min=1,max=3) #输出的结果是2 Zincrby 命令对有序集合中指定成员的分数加上增量 increment 可以通过传递一个负数值 increment ，让分数减去相应的值，比如 ZINCRBY key -5 member ，就是让 member 的 score 值减去 5 。 当 key 不存在，或分数不是 key 的成员时， ZINCRBY key increment member 等同于 ZADD key increment member 。 当 key 不是有序集类型时，返回一个错误。 分数值可以是整数值或双精度浮点数。 member 成员的新分数值，以字符串形式表示。 print r.zadd(\"4\",\"1\",1,\"2\",2,\"3\",3,\"4\",4) #输出的结果是4 print r.zincrby(name=4,value=1,amount=5) #输出的结果是6.0 print r.zincrby(name=4,value=2,amount=55) #输出的结果是57.0 print r.zrange(name=4,start=0,end=-1,withscores=False) #输出的结果是['1', '3', '2', '4'] Zinterstore 命令计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination 。 默认情况下，结果集中某个成员的分数值是所有给定集下该成员分数值之和。 print r.zadd(\"41\", \"a1\", 6, \"a2\", 2,\"a3\",5) #输出的结果是3 print r.zadd('42', a1=7,b1=10, b2=5) #输出的结果是3 # 获取两个有序集合的交集并放入dest集合，如果遇到相同值不同分数，则按照aggregate进行操作 # aggregate的值为: SUM MIN MAX print r.zinterstore(\"43\",(\"42\",\"41\"),aggregate=\"MAX\") #输出的结果是4 print(r.zscan(\"43\")) #输出的结果是(0L, [('a1', 7.0)]) Zlexcount 命令在计算有序集合中指定字典区间内成员数量。 print r.zadd(\"6\", \"a\", 1, \"b\", 2,\"c\",3) #输出的结果是3 print r.zlexcount(name=6,min=\"-\",max=\"+\") #输出的结果是3 print r.zadd(\"6\", \"e\", 4, \"f\", 5,\"d\",6) #输出的结果是3 print r.zlexcount(name=6,min=\"-\",max=\"+\") #输出的结果是6 print r.zlexcount(name=6,min=\"[a\",max=\"[b\") #输出的结果是2 print r.zlexcount(name=6,min=\"[a\",max=\"[f\") #输出的结果是6 print r.zlexcount(name=6,min=\"[a\",max=\"[e\") #输出的结果是4 Zrange 返回有序集中，指定区间内的成员。其中成员的位置按分数值递增(从小到大)来排序。具有相同分数值的成员按字典序(lexicographical order )来排列。 如果你需要成员按值递减(从大到小)来排列，请使用 ZREVRANGE 命令。 下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。 你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。 print r.zadd(\"7\", \"1\", 1, \"2\", 2,\"3\",3,\"4\",4,\"5\",5) #输出的结果是5 print r.zrange(\"7\",start=0,end=-1,desc=False) #输出的结果是['1', '2', '3', '4', '5'] print r.zrange(\"7\",start=0,end=2,desc=False) #输出的结果是['1', '2', '3'] Zrangebylex 通过字典区间返回有序集合的成员。 当有序集合的所有成员都具有相同的分值时，有序集合的元素会根据成员的 值 （lexicographical ordering）来进行排序，而这个命令则可以返回给定的有序集合键 key 中， 元素的值介于 min 和 max 之间的成员 对集合中的每个成员进行逐个字节的对比（byte-by-byte compare）， 并按照从低到高的顺序， 返回排序后的集合成员。 如果两个字符串有一部分内容是相同的话， 那么命令会认为较长的字符串比较短的字符串要大 print r.zadd(\"8\", \"a\", 1, \"b\", 2,\"c\",3) #输出的结果是3 print r.zrangebylex(name=\"8\",min=\"-\",max=\"[c\") #输出的结果是 ['a', 'b', 'c'] print r.zrangebylex(name=\"8\",min=\"-\",max=\"(c\") #输出的结果是 ['a', 'b'] print r.zadd(\"8\", \"e\", 4, \"f\", 5,\"d\",6) #输出的结果是3 print r.zrangebylex(name=8,min=\"[b\",max=\"[f\") #输出的结果是 ['b', 'c', 'e', 'f', 'd'] print r.zrangebylex(name=8,min=\"(b\",max=\"[f\") #输出的结果是 ['c', 'e', 'f', 'd'] Zrangebyscore 返回有序集合中指定分数区间的成员列表。有序集成员按分数值递增(从小到大)次序排列。 具有相同分数值的成员按字典序来排列(该属性是有序集提供的，不需要额外的计算)。 默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于)。 print r.zadd(\"9\", \"a\", 1, \"b\", 2,\"c\",3) #输出的结果是3 print r.zrangebyscore(\"9\",\"1\",\"6\") #输出的结果是['a', 'b', 'c'] print r.zadd(\"9\", \"c\", 11, \"d\", 21,\"e\",32) #输出的结果是3 print r.zrangebyscore(\"9\",\"3\",\"16\") #输出的结果是['c'] print r.zrangebyscore(\"9\",\"3\",\"36\") #输出的结果是['c', 'd', 'e'] Zrank 返回有序集中指定成员的排名。其中有序集成员按分数值递增(从小到大)顺序排列。 如果成员是有序集 key 的成员，返回 member 的排名。如果成员不是有序集 key 的成员，返回 None 。 print r.zadd(\"10\", \"a\", 1, \"b\", 2, \"c\", 3) # 输出的结果是3 print r.zadd(\"10\", \"f\", 11, \"d\", 21,\"e\",32) #输出的结果是3 print r.zrank(\"10\",\"a\") #输出的结果是0 print r.zrank(\"10\",\"b\") #输出的结果是1 print r.zrank(\"10\",\"e\") #输出的结果是5 print r.zrank(\"10\",\"d\") #输出的结果是4 print r.zrank(\"10\",\"h\") #输出的结果是None Zrem 命令用于移除有序集中的一个或多个成员，不存在的成员将被忽略。 当 key 存在但不是有序集类型时，返回一个错误。 print r.zadd(\"11\", \"a\", 1, \"b\", 2, \"c\", 3) # 输出的结果是3 print r.zadd(\"11\", \"f\", 11, \"d\", 21,\"e\",32) #输出的结果是3 print r.zrem(\"11\",\"a\") #输出的结果是1 print r.zrem(\"11\",\"f\") #输出的结果是1 print r.zrem(\"11\",\"h\") #输出的结果是0 print r.zrange(\"11\",start=0,end=32) #输出的结果是['b', 'c', 'd', 'e'], 其中a f已经移除掉 print r.zrange(\"11\",start=2,end=32) #输出的结果是['d','e'], 其中af已经移除掉，de没有被包涵 Zremrangebylex 命令用于移除有序集合中给定的字典区间的所有成员。 被成功移除的成员的数量，不包括被忽略的成员。 print r.zadd(\"12\", \"a\", 1, \"b\", 2, \"c\", 3) # 输出的结果是3 print r.zadd(\"12\", \"d\", 11, \"e\", 21,\"f\",32) #输出的结果是3 print r.zremrangebylex(\"12\",min=\"[a\",max=\"[c\") #输出的结果是3 print r.zrange(\"12\",0,-1) #输出的结果是 ['d', 'e', 'f'] 因为 a，b，c已经被移除 Zremrangebyrank 命令用于移除有序集中，指定排名(rank)区间内的所有成员。 print r.zadd(\"13\", \"a\", 1, \"b\", 2, \"c\", 3) # 输出的结果是3 print r.zadd(\"13\", \"d\", 8, \"e\", 21,\"f\",32) #输出的结果是3 print r.zremrangebyrank(name=13,min=1,max=3) #输出的结果是3 print r.zrange(\"13\",\"0\",\"-1\") #输出的结果是['a', 'e', 'f'] 因为删除了 b，c，d Zremrangebyscore 命令用于移除有序集中，指定分数（score）区间内的所有成员。 print r.zadd(\"14\", \"a\", 1, \"b\", 2, \"c\", 3) #输出的结果是3 print r.zadd(\"14\", \"d\", 8, \"e\", 21,\"f\",32) #输出的结果是3 print r.zremrangebyscore(name=\"14\",min=\"1\",max=\"8\") #输出的结果是4,删除的a，b，c，d print r.zrange(name=\"14\",start=0,end=-1) #输出的结果是 ['e', 'f'] Zrevrange 命令返回有序集中，指定区间内的成员。其中成员的位置按分数值递减(从大到小)来排列。 具有相同分数值的成员按字典序的逆序(reverse lexicographical order)排列。 除了成员按分数值递减的次序排列这一点外， ZREVRANGE 命令的其他方面和 ZRANGE 命令一样。 print r.zadd(\"15\", \"a\", 1, \"b\", 2, \"c\", 3) #输出的结果是3 print r.zadd(\"15\", \"d\", 8, \"e\", 21,\"f\",32) #输出的结果是3 print r.zrevrange(name=\"15\",start=0,end=-1) #输出的结果是['f', 'e', 'd', 'c', 'b', 'a'] print r.zrevrange(name=\"15\",start=1,end=21) #输出的结果是['e', 'd', 'c', 'b', 'a'] print r.zrevrange(name=\"15\",start=3,end=21) #输出的结果是['c', 'b', 'a'] Zrevrangebyscore 返回有序集中指定分数区间内的所有的成员。有序集成员按分数值递减(从大到小)的次序排列。 具有相同分数值的成员按字典序的逆序(reverse lexicographical order )排列。 除了成员按分数值递减的次序排列这一点外， ZREVRANGEBYSCORE 命令的其他方面和 ZRANGEBYSCORE 命令一样。 print r.zadd(\"16\", \"a\", 1, \"b\", 2, \"c\", 3) #输出的结果是3 print r.zadd(\"16\", \"d\", 8, \"e\", 21,\"f\",32) #输出的结果是3 print r.zrevrangebyscore(name=\"16\",max=33,min=0) #输出的结果是['f','e','d','c','b','a'] print r.zrevrangebyscore(name=\"16\",max=20,min=2) #输出的结果是['d', 'c', 'b'] Zrevrank 命令返回有序集中成员的排名。其中有序集成员按分数值递减(从大到小)排序。 排名以 0 为底，也就是说， 分数值最大的成员排名为 0 。 使用 ZRANK 命令可以获得成员按分数值递增(从小到大)排列的排名。 print r.zadd(\"17\", \"a\", 1, \"b\", 2, \"c\", 3) #输出的结果是3 print r.zadd(\"17\", \"d\", 4, \"e\", 5,\"f\",6) #输出的结果是3 print r.zrevrank(name=17,value=\"a\") #输出的结果是5 print r.zrevrank(name=17,value=\"c\") #输出的结果是3 print r.zrevrank(name=17,value=\"d\") #输出的结果是2 print r.zrevrank(name=17,value=\"h\") #输出的结果是None Zscore 命令返回有序集中，成员的分数值。 如果成员元素不是有序集 key 的成员，或 key 不存在，返回 None 。print r.zadd(\"18\", \"a\", 1, \"b\", 2, \"c\", 3) #输出的结果是3 print r.zadd(\"18\", \"d\", 4, \"e\", 5,\"f\",6) #输出的结果是3 print r.zscore(name=\"18\",value=\"a\") #输出的结果是1.0 print r.zscore(name=\"18\",value=\"c\") #输出的结果是3.0 print r.zscore(name=\"18\",value=\"f\") #输出的结果是6.0 print r.zscore(name=\"18\",value=\"h\") #输出的结果是None Zunionstore 命令计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination 。 默认情况下，结果集中某个成员的分数值是所有给定集下该成员分数值之和 。 保存到 destination 的结果集的成员数量。 Zscan 命令用于迭代有序集合中的元素（包括元素成员和元素分值） 返回的每个元素都是一个有序集合元素，一个有序集合元素由一个成员（member）和一个分值（score）组成。print r.zadd(\"20\", \"a\", 1, \"b\", 2, \"c\", 3) #输出的结果是3 print r.zscan(name=\"20\") #输出的结果是(0L, [('a', 1.0), ('b', 2.0), ('c', 3.0)]) print r.zadd(\"20\", \"d\", 4, \"e\", 5,\"f\",3) #输出的结果是3 print r.zscan(name=\"20\") #输出的结果是 (0L, [('a', 1.0), ('b', 2.0), ('c', 3.0), ('f', 3.0), ('d', 4.0), ('e', 5.0)]) "},"redis/redis-python-hyperlog.html":{"url":"redis/redis-python-hyperlog.html","title":"2.3.7. redis-hyperlog","keywords":"","body":"2.3.7 python操作redis之HyperLogLog #coding:utf8 import redis # python 操作redis之——HyperLogLog r =redis.Redis(host=\"106.13.168.8\",port=6379,password=\"123456\") Pfadd 命令将所有元素参数添加到 HyperLogLog 数据结构中。 print r.pfadd(\"1\",\"1\",\"2\") #输出结果是1 print r.pfadd(\"1\",\"3\",\"4\") #输出结果是1 print r.pfadd(\"1\",\"4\",\"5\") #输出结果是1 Pfcount 命令返回给定 HyperLogLog 的基数估算值。 print r.pfcount(\"1\") #输出结果是5, 因为 4 重复了两次 print r.pfcount(\"2\") #输出结果是0 "},"redis/redis-python-example.html":{"url":"redis/redis-python-example.html","title":"2.3.8. 应用示例","keywords":"","body":"2.3.8 python操作redis之应用示例 import redis class RedisDB(object): def __init__(self, conf): self.conn = redis.Redis( connection_pool=redis.ConnectionPool( host=conf['redis_host'], port=conf['redis_port'], db=conf['redis_db'], password=conf['redis_passwd'] ) ) def set(self, key, value, expire=None): self.conn.set(key, value, expire) def get(self, key): return self.conn.get(key) def setex(self, key, expire_time, strval): return self.conn.setex(key, expire_time, strval) def scan(self, cursor=0, match=None, count=None): data = self.conn.scan(cursor=cursor, match=match, count=count) return data def delete(self, key): self.conn.delete(key) def hdel(self, name, key): return self.conn.hdel(name, key) def hset(self, name, key, value): self.conn.hset(name, key, value) def hget(self, key, fields): return self.conn.hget(key, fields) def hmset(self, key, fields): self.conn.hmset(key, fields) def hgetall(self, name): data = self.conn.hgetall(name) data = dict((item[0].decode('utf-8'), item[1].decode('utf-8')) for item in data.items()) if data else None return data def hscan(self, name, cursor=0, match=None, count=None): data = self.conn.hscan(name, cursor=cursor, match=match, count=count) return data def hvals(self, key): return self.conn.hvals(key) def hkeys(self, key): return self.conn.hkeys(key) def hdel(self, key, field): self.conn.hdel(key, field) def exists(self, key): return self.conn.exists(key) def hexists(self, name, key): return self.conn.hexists(name, key) def delete(self, *names): return self.conn.delete(*names) def expire(self, name, time): return self.conn.expire(name, time) "},"redis/redis-python-strict.html":{"url":"redis/redis-python-strict.html","title":"2.3.9. Redis与StrictRedis区别","keywords":"","body":"2.3.8 python操作redis之redis.Redis与redis.StrictRedis区别 redis-py提供两个类Redis和StrictRedis用于实现Redis的命令 StrictRedis用于实现大部分官方的命令,并使用官方的语法和命令 Redis是StrictRedis的子类,用于向后兼容旧版本的redis-py。 官方推荐使用StrictRedis方法。Redis类和redis-cli操作有些不一样, 三个方面。 LREM:参数'num'和'value'的顺序交换了一下,cli是 lrem queueName 0 'string' , 0是所有 但是Redis这个类,把控制和string调换了。 ZADD:实现时score和value的顺序不小心弄反了,后来有人用了,就这样了 SETEX:time和value的顺序反了 Redis的连接池的方法: pool = redis.ConnectionPool(host='localhost', port=6379, db=0) r = redis.Redis(connection_pool=pool) StrictRedis的连接池的实现方式: pool = redis.ConnectionPool(host='127.0.0.1', port=6379) r = redis.StrictRedis(connection_pool=pool) 官方的创建redis的时候,都可以添加什么参数 class redis.StrictRedis(host='localhost', port=6379, db=0, password=None, socket_timeout=None, connection_pool=None, charset=‘utf-8’, errors=‘strict’, decode_responses=False, unix_socket_path=None) Implementation of the Redis protocol. This abstract class provides a Python interface to all Redis commands and an implementation of the Redis protocol. Connection and Pipeline derive from this, implementing how the commands are sent and received to the Redis server redis的对于有些编码入库的问题,redis的连接附加的参数里面,默认编码是utf-8,但是如果你非要用GBK那就需要指明你的chardet和decode_responses为True 。 "},"mongo/SUMMARY.html":{"url":"mongo/SUMMARY.html","title":"1.1安装配置","keywords":"","body":"Summary Introduction "},"mongo/windos-install.html":{"url":"mongo/windos-install.html","title":"1.1.1windos","keywords":"","body":""},"mongo/ubuntu-install.html":{"url":"mongo/ubuntu-install.html","title":"1.1.2ubuntu","keywords":"","body":""},"mongo/centos-install.html":{"url":"mongo/centos-install.html","title":"1.1.3centos","keywords":"","body":""}}